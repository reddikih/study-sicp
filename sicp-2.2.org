* 2.2 階層データと閉包性

- ペアは（このシステムでは？それとも普遍的に？）複合データオブジェクト
  を構築する基本的な糊となる
- 箱とポインタ記法 (/box-and-pointer notation/)
  - それぞれのオブジェクトは箱へのポインタとして表される
  - 基本（データの）オブジェクトの箱にはオブジェクトの表現（数値なら数
    字等）が入っている
- 図2.2の例
  - (cons 1 2) で作られるペアを表している
  - ペアの箱は実際には2つの箱で、左の箱にはペアのcarへのポインタが入り、
    右の箱にはペアのcdrへのポインタが入る
- *consの閉包性 (closure property)*
  - ペアを要素とするペアを作る能力
- 一般的に、データオブジェクトを組み合わせる操作は、その演算による組み
  合わせの結果自身が、同じ演算によって組み合わせることができるのであれ
  ば、閉包性を満たす
- 閉包によって *階層(hierarchical)* 構造 -- 部品によって作られ、その部
  品もまた部品よって作られ…という構造 -- を作ることが可能になる

* 2.2.1 列の表現

- ペアを使って構築できる便利な構造の一つは *列(sequence)*
  - 列とはデータオブジェクトの順序付き集合
- 図2.4は素直な表現方法の一つを示している
  - 1,2,3,4の列はペアのチェーンとして表される
  - 最後のペアのcdrはペアではない特別な値を指すことで列の終端であるこ
    とを伝える
    - 箱ポインタ図では斜線で表され、プログラムでは変数nilという値で表
      される
      - *(引田コメント):* nilは変数？
  #+BEGIN_SRC scheme
  ;; 図2.4をプログラムで表現する
  (cons 1 (cons 2 (cons 3 (cons 4 nil))))
  #+END_SRC
- 入れ子のconsによって作られるペアの列は *リスト(/list/)* と呼ばれる
  - 図2.4の例は ~(list 1 2 3 4)~ によって生成できる。

listの構文
#+BEGIN_SRC scheme
(list <a1> <a2> ... <an>)

;; は以下と等価
(cons <a1> (cons <a2> (cons ... (cons <an> nil) ... )))
#+END_SRC

#+BEGIN_SRC scheme
(define one-through-four (list 1 2 3 4))
one-through-four
(1 2 3 4)
#+END_SRC

- carはリストの最初の項を選択し、cdrは最初の項以外の全てからなる部分リ
  ストを選択するものと考えられる
- carとcdrを入れ子にしていくとリストの任意の項を取得できる
- コンストラクタconsは元のリストと同じリストに最初に一つ項が加わったものを作る
#+BEGIN_SRC scheme
(car one-through-four)
1
(cdr one-through-four)
(2 3 4)
(car (cdr one-through-four))
2
(cons 10 one-through-four)
(10 1 2 3 4)
(cons 5 one-through-four)
(5 1 2 3 4)
#+END_SRC

- *nil* は要素のない列、すなわち *空リスト(/empty list/)* と考えること
  もできる

** リスト演算

*cdrダウン* : 確率されたプログラミングテクニック
 
- *例1) list-ref* list-ref手続きは引数としてリストと数値nを取り、リス
  トのn番目のものを返す
  - n = 0 であれば、list-refはリストのcarを返す
  - そうでなければ、list-refはリストのcdrの(n-1)番目のものを返す
#+BEGIN_SRC scheme
(define (list-ref items n)
  (if (= n 0)
      (car items)
      (list-ref (cdr items) (- n 1))))

(define squares (list 1 4 9 16 25))
(list-ref squares 3)
;; 16
#+END_SRC

- リスト全体をcdrダウンするために、Schemeは基本述語null?を持っている
  - null?は、引数が空リストかどうかテストするもの

- *例2) length* lenghtはリストの要素数を返す手続き
#+BEGIN_SRC scheme
;; 再帰プロセス
(define (lenght items)
  (if (null? items)
      0
      (+ 1 (length (cdr items)))))

(define odds (list 1 3 5 7))
(length odds)
;; 4
#+END_SRC

- lengthの反復プロセススタイル
#+BEGIN_SRC scheme
(define (length items)
  (define (length-iter a count)
    (if (null? a)
        count
        (length-iter (cdr a) (+ 1 count))))
  (length-iter items 0))
#+END_SRC


*consアップ* もう一つの確率されたプログラミングテクニック

- *例3) append* appendは2つのリストを引数として取り、要素を連結して新しいリストを作る
- appendの再帰計画
  - もしlist1が空リストであれば、結果は単にlist2である
  - そうでなければ、list1のcdrとlist2をappendし、その結果にlist1のcarをconsする
#+BEGIN_SRC scheme
(define (append list1 list2)
  (if (null? list1)
      list2
      (cons (car list1) (append (cdr list1) list2))))
#+END_SRC

動作確認
#+BEGIN_SRC scheme
(append squares odds)
> (1 4 9 16 25 1 3 5 7)
(append odds squares)
> (1 3 5 7 1 4 9 16 25)
#+END_SRC

** 練習問題
*** 練習問題 2.17

#+BEGIN_SRC scheme
(define (last-pair items)
  (if (null? (cdr items))
      items    ;; required by gauche. "nil" cannot be used in it.
      (last-pair (cdr items))))
#+END_SRC

動作確認
#+BEGIN_SRC scheme
(last-pair (list 23 72 149 34))
;; (34)
#+END_SRC

*** 練習問題 2.18

#+BEGIN_SRC scheme
(define (reverse items)
  (define (iter src dest)
    (if (null? src)
        dest
        (iter (cdr src) (cons (car src) dest))))
  (iter items '()))
#+END_SRC

動作確認
#+BEGIN_SRC scheme
(reverse (list 1 4 9 16 25))
;; (25 16 9 4 1)
#+END_SRC

*** 練習問題 2.19
TBD
*** 練習問題 2.20

*ドット末尾記法 (dotted-tail notation)* は覚えておくこと

回答
#+BEGIN_SRC scheme
(define (same-parity base . rest)
  (define (check-and-add b target chain)
    (if (eq? (odd? b) (odd? target))
        (cons chain target)
        chain))
  (define (iter src result)
    (if (null? src)
        result
        (iter (cdr src) (check-and-add base (car src) result))))
  (iter rest (cons base '())))
#+END_SRC

動作確認
#+BEGIN_SRC 
(same-parity 1 2 3 4 5 6 7 8)
(same-parity 2 3 4 5 6 7 8)
#+END_SRC

練習
#+BEGIN_SRC scheme
(define (g . w) w)
(g 1 2 3)
;; (1 2 3)
(g)
;; () ;; 0個以上の引数に対応する。引数が0個の場合は空リストを返す
#+END_SRC



** リストに対するマップ

- 非常に便利な演算としてリストのそれぞれの要素に何らかの変換を適用し、
  結果のリストを返すというものがある

*例) scale-list* scale-listは、与えられた係数をリストの其々の数値にかける
#+BEGIN_SRC scheme
(define (scale-list items factor)
  (if (null? items)
      '() ;; for gauche
      (cons (* (car items) factor)
            (scale-list (cdr items) factor))))
;; 動作確認
(scale-list (list 1 2 3 4 5) 10)
#+END_SRC

この一般的な考え方を抽象化し、mapとよばれる高階手続きによって表現され
る共通パターンとして捉えることができる。

mapは、1引数の手続きとリストを引数としてとり、リストのそれぞれの要素に
手続きを適用した結果のリストを返す。

#+BEGIN_SRC scheme
(define (map proc items)
  (if (null? items)
      '()
      (cons (proc (car items))
            (map proc (cdr items)))))
;; 動作例
(map abs (list -10 2.5 -11.6 17))
; (10 2.5 11.6 17)
(map (lambda (x) (* x x)) (list 1 2 3 4))
; (1 4 9 16)
#+END_SRC

mapを使ってscale-listの新しい定義を書ける。
#+BEGIN_SRC scheme
(define (scale-list items factor)
  (map (lambda (x) (* x factor)) items))
#+END_SRC

- mapはリストを扱ううえでのより高いレベルの抽象化を達成する。
- mapはリストを変形する手続きの実装を、リストの要素をどうやって取り出
  して結合していくかという細かいところから切り離す *抽象化の壁* を作る
  ことを助けてくれる

** 練習問題
*** 練習問題 2.21
1つ目のsquare-listの定義
#+BEGIN_SRC scheme
(define (square x) (* x x))
(define (square-list items)
  (if (null? items)
      '() ;; for gauche
      (cons (square (car items)) (square-list (cdr items)))))
#+END_SRC

2つ目のsquare-listの定義
#+BEGIN_SRC scheme
(define (square-list items)
  (map square items))
#+END_SRC

動作チェック
#+BEGIN_SRC scheme
(square-list (list 1 2 3 4))
#+END_SRC

*** 練習問題 2.22

#+BEGIN_SRC scheme
(define (square-list items)
  (define (iter things answer)
    (if (null? things)
        answer
        (iter (cdr things)
              (cons (square (car things))
                    answer))))
  (iter items '()))

;; 動作確認: 逆順になってしまう
(square-list (list 1 2 3 4))
> (16 9 4 1) 
#+END_SRC

逆順になってしまう理由
- インタプリタが適用順序評価なので、iter呼び出し時の第2引数のconsはさきに計算される
- 次にiterを実行したとき、answerに一つ前のiteration時のcarの値でペアが作られている
  - 現在のiteration時の(car things)の後ろに一つ前までのリスト（ペアの
    ネスト構造）が追加されている
置換モデルでiterationの部分のみを抜き出してみると以下のような動きになる
#+BEGIN_SRC scheme
(square-list (list 1 2 3 4))
(square-list (1 2 3 4))
...
(iter (2 3 4) (cons 1 '()))
(iter (3 4) (cons 4 (cons 1 '())))
(iter (4) (cons 9 (cons 4 (cons 1 '()))))
(iter '() (cons 16 (cons 9 (cons 4 (cons 1 '())))))
(cons 16 (cons 9 (cons 4 (cons 1 '()))))
(16 9 4 1)
#+END_SRC
  
#+BEGIN_SRC scheme
;; consの引数を逆にしたバージョン。これも上手くいかない
(define (square-list items)
  (define (iter things answer)
    (if (null? things)
        answer
        (iter (cdr things)
              (cons answer
                    (square (car things))))))
  (iter items '()))

;; 動作確認。リストにならない
(square-list (list 1 2 3 4))
> ((((() . 1) . 4) . 9) . 16)
#+END_SRC

consの引数を逆にしても上手くいかない理由
- これもiter呼び出し時のconsは適用順序評価なので先に評価される
- listはペアの連鎖であり、各ペアのcarがリストの要素値でconsは次のリス
  ト要素であるペアへのポインタか、リストの末尾を表す空リスト'()のいず
  れかでなければならない。
- このプログラムではconsでcarには一つ前のiterationまでの結果を指定し、
  cdrには当該iterationにおけるリストのcarを付けているので、このペアは
  リストにはならない
置換モデルでiterationの部分のみを抜き出してみると以下のような動きになる
#+BEGIN_SRC scheme
(square-list (list 1 2 3 4))
(square-list (1 2 3 4))
...
(iter (2 3 4) (cons '() 1))
(iter (3 4) (cons (cons '() 1) 4))
(iter (4) (cons (cons (cons '() 1) 4) 9))
(iter '()) (cons (cons (cons (cons '() 1) 4) 9) 16))
(cons (cons (cons (cons '() 1) 4) 9) 16)
((((() . 1) . 4) . 9) . 16)
#+END_SRC


*** 練習問題 2.23

* 2.2.2 階層構造

- リストによる列の表現は、要素がそれ自身列であるような列を表現するよう
  に一般化できる
- ((1 2) 3 4)は、 ~(cons (list 1 2) (list 3 4))~ のように3つの項目を持
  つリストとして見ることが出来る
  - 1つ目の項目はそれ自身が (1 2) というリストということになる
  - 図2.5はこのリストのペアによる表現
- 要素が列であるような列は *木(tree)* として考えることが出来る
  - 列の要素: 木の枝
  - それ自身が列である要素は部分木
- 再帰は木構造を扱う自然なツール
  - 木への演算をその枝に対する演算に縮約
  - 枝の枝に対する演算に縮約... と続けていくことで木の葉にたどり着く
- 例) 2.2.1節の length手続きと木の葉の総数を返すcount-leaves手続きの比較
#+BEGIN_SRC scheme
;; length手続き from 2.2.2
(define (lenght items)
  (if (null? items)
      0
      (+ 1 (length (cdr items)))))

(define x (cons (list 1 2) (list 3 4)))
(length x)
3
(count-leaves x) ;; 今の時点では未実装
4
#+END_SRC

- lengthの再帰計画
  - リストxのlegnthは、xのcdrのlengthに1を足した値である
  - 空リストのlengthは0である
- count-leavesの再帰計画
  - 空リストのcount-leavesは0である
  - 葉のcount-leavesは1である
  - 木xのcount-leavesは、xのcarのcount-leavesとxのcdrのcount-leavesを足した値である

木に対する再帰手続きが書きやすくなるようにschemeでは ~pair?~ という基
本述語を提供している。pairは引数がペアであるかどうかテストする。

以下はcount-leavesの実装
#+BEGIN_SRC scheme
(define (count-leaves x)
  (cond ((null? x) 0)                       ;; - 空リストのcount-leavesは0である
        ((not (pair? x)) 1)                 ;; - 葉のcount-leavesは1である
        (else (+ (count-leaves (car x))     ;; - 木xのcount-leavesは、xのcarのcount-leavesと
                 (count-leaves (cdr x)))))) ;;   xのcdrのcount-leavesを足した値である
#+END_SRC

動作確認
#+BEGIN_SRC scheme
(define x (cons (list 1 2) (list 3 4)))
(count-leaves x)
;; 4
(list x x)
(length (list x x))
;; 2
(count-leaves (list x x))
;; 8
#+END_SRC

*** 練習問題
**** 練習問題 2.24
式: (list 1 (list 2 (list 3 4)))

インタプリタの表示結果
#+BEGIN_SRC scheme
;; gosh
(list 1 (list 2 (list 3 4)))
;; -> (1 (2 (3 4)))
#+END_SRC

箱-点構造図
[[./img/sicp_2-2-2_ex2-24_01.png]]

木の表現
[[./img/sicp_2-2-2_ex2-24_02.png]]

**** 練習問題 2.25
#+BEGIN_SRC scheme
;; (1 3 (5 7) 9) から7を取り出す
(define x (list 1 3 (list 5 7) 9))
(car (cdr (car (cdr (cdr x)))))

;; ((7))
(define x (list (list 7)))
(car (car x))

;; (1 (2 (3 (4 (5 (6 7))))))
(define x (list 1 (list 2 (list 3 (list 4 (list 5 (list 6 7)))))))
(car (cdr (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr x))))))))))))
#+END_SRC

**** 練習問題 2.26
#+BEGIN_SRC scheme
;; append
(define (append list1 list2)
  (if (null? list1)
      list2
      (cons (car list1) (append (cdr list1) list2))))
#+END_SRC

#+BEGIN_SRC scheme
(define x (list 1 2 3))
(define y (list 4 5 6))

(append x y) ;; (1 2 3 4 5 6)
(cons x y)   ;; ((1 2 3) 4 5 6)
(list x y)   ;; ((1 2 3) (4 5 6))
#+END_SRC

**** 練習問題 2.27

回答
#+BEGIN_SRC scheme
(define (deep-reverse items)
  (define (iter src dest)
    (if (null? src)
        dest
        (iter (cdr src) (cons (if (pair? (car src)) ;; この(car src)はlet使ってローカル変数にできそう
                                  (deep-reverse (car src))
                                  (car src))
                              dest))))
  (iter items '()))
#+END_SRC

動作確認
#+BEGIN_SRC scheme
;; (1 2 3 4) -> (4 3 2 1)
(define x (list 1 2 3 4))
(deep-reverse x)
gosh> (4 3 2 1)

;; ((1 2) (3 4)) -> ((4 3) (2 1))
(define y (list (list 1 2) (list 3 4)))
(deep-reverse y)
gosh> ((4 3) (2 1))

;; (1 (2 3 (4 5)) ((6 7) (8 9))) -> (((9 8) (7 6)) ((5 4) 3 2) 1)
(define z (list 1 (list 2 3 (list 4 5)) (list (list 6 7) (list 8 9))))
(deep-reverse z)
gosh> (((9 8) (7 6)) ((5 4) 3 2) 1)
#+END_SRC

**** 練習問題 2.28

練習: 葉の値を表示する
#+BEGIN_SRC scheme
;; 練習: disp-leaves: display leaves
(define (disp-leaves x)
  (cond ((null? x) (display '()))
        ((not (pair? x)) (display x))
        (else (begin (disp-leaves (car x))
                     (disp-leaves (cdr x))))))

(disp-leaves (list 1 2 3 4))
(disp-leaves (list (list 1 2) (list 3 4)))
#+END_SRC

回答
#+BEGIN_SRC scheme
;; 補助関数
(define (append list1 list2)
  (if (null? list1)
      list2
      (cons (car list1) (append (cdr list1) list2))))

;; ボツ回答1
(define (fringe x)
  (cond ((not (pair? x)) (cons x '()))
        ((null? (cdr x)) x)
        (else (append (fringe (car x))
                      (fringe (cdr x))))))

;; ボツ回答2
(define (fringe x)
  (cond ((null? x) '())
        ((not (pair? x)) x)
        (else (cons (if (pair? (car x))
                        (fringe (car x))
                        (car x))
                    (fringe (cdr x))))))

;; ボツ回答3. 実行時エラー
(define (fringe x)
  (define (iter src dest)
    (cond ((null? src) dest)
          ((not (pair? src)) src))
	  (else (iter (cdr src) (cons (if (pair? (car src))
                                          (iter (car src) dest)
                                          (car src)))))))
  (iter x '()))

;; ボツ回答4. 実行時エラー
(define (fringe x)
  (cond ((null? x) '())
        ((not (pair? x)) x)
        (else (if (pair? (car x))
                  (cons (fringe (car x)) (fringe (cdr x)))
                  (car x))
               (fringe (cdr x)))))

;; ボツ回答5. リストは作れているがreverseしてしまっている
(define (fringe x)
  (define (iter src dest)
    (if (null? src)
        dest
        (iter (cdr src) (append (if (pair? (car src))
                                    (fringe (car src))
                                    (cons (car src) '()))
                                dest))))
  (iter x '()))

;; 回答6. ボツ回答のappendの引数を逆に変更
(define (fringe x)
  (define (iter src dest)
    (if (null? src)
        dest
        (iter (cdr src)
              (append dest
                      (if (pair? (car src))
                          (fringe (car src))
                          (cons (car src) '()))))))
  (iter x '()))
#+END_SRC

動作確認
#+BEGIN_SRC scheme
(fringe (list 1))                     ;; expect to (1)
> (1)
(fringe (list 1 2 3 4))               ;; expect to (1 2 3 4)
> (1 2 3 4)
(fringe (list (list 1 2) (list 3 4))) ;; expect to (1 2 3 4)
> (1 2 3 4)
(fringe (list (list 1 2) 3))          ;; expect to (1 2 3)
> (1 2 3)

(define x (list (list 1 2) (list 3 4))) ;; expect to (1 2 3 4 1 2 3 4)
(fringe (list x x))
> (1 2 3 4 1 2 3 4)
#+END_SRC

**** 練習問題 2.29

#+BEGIN_SRC scheme
(define (make-mobile left right) (list left right))
(define (make-branch length structure) (list length structure))
#+END_SRC

***** a. セレクタと枝の構成要素を返す手続き
#+BEGIN_SRC scheme
;; selectors of a mobile
(define (left-branch mobile) (car mobile))
(define (right-branch mobile) (car (cdr mobile)))

;; selectors of a branch
(define (branch-length branch) (car branch))
(define (branch-structure branch) (car (cdr branch)))
#+END_SRC

***** b. モビールの総重量を返す手続き: total-weight
#+BEGIN_SRC scheme
(define (total-weight mobile)
  (+ (branch-weight (left-branch mobile))
     (branch-weight (right-branch mobile))))

(define (branch-weight branch)
  (let ((struct (branch-structure branch)))
    (cond ((null? struct) 0) ;; このケースがあり得るのかは不明
          ((not (pair? struct)) struct)
          (else (total-weight struct)))))
#+END_SRC

動作確認
#+BEGIN_SRC scheme
(define m1 (make-mobile (make-branch 1 2)
                        (make-branch 3 4)))
(define m2 (make-mobile (make-branch 2 5)
                        (make-branch 2 6)))
(define m3 (make-mobile (make-branch 3 4)
                        (make-branch 3 7)))
(define m4 (make-mobile (make-branch 4 m2)
                        (make-branch 4 m3)))
(define m5 (make-mobile (make-branch 5 m1)
                        (make-branch 5 m4)))
(total-weight m1) ;; expected to 6
> 6
(total-weight m2) ;; expected to 11
> 11
(total-weight m4) ;; expected to m2:11 + m3:11 = 22
> 22
(total-weight m5) ;; expected to m1:6 + m4:22 = 28
> 28
#+END_SRC

***** c. バランスが取れているかのテスト

#+BEGIN_SRC scheme
(define (balanced? mobile)
  (and (eq? (branch-torque (left-branch mobile))
            (branch-torque (right-branch mobile)))
       (branch-balanced? (left-branch mobile))
       (branch-balanced? (right-branch mobile))))

(define (branch-torque branch)
  (* (branch-length branch)
     (branch-weight branch)))

(define (branch-balanced? branch)
  (let ((struct (branch-structure branch)))
    (cond ((null? struct) #t)
          ((not (pair? struct)) #t)
          (else (balanced? struct)))))
#+END_SRC

動作確認
#+BEGIN_SRC scheme
(define b1 (make-branch 2 4))
(define b2 (make-branch 4 2))
(define b3 (make-branch 3 5))
(define b4 (make-branch 10 3))
(define m1 (make-mobile b1 b2))
(define m2 (make-mobile b1 b3))
(define b5 (make-branch 5 m1))
(define m3 (make-mobile b4 b5))

(balanced? m1) ;; expected to true
> #t
(balanced? m2) ;; expected to false
> #f
(balanced? m3) ;; expected to true
> #t

(define b11 (make-branch 7 5))
(define b12 (make-branch 5 (make-mobile (make-branch 2 4)
                                        (make-branch 2 3))))
(define m10 (make-mobile b11 b12))

(balanced? m10) ;; expected to false
> #f
#+END_SRC

***** d. モビールの表現を変更したときのプログラム変更の影響度合い

変更内容: モビールと枝のデータ構造をリストではなくconsに変更
#+BEGIN_SRC scheme
(define (make-mobile left right) (cons left right))
(define (make-branch length structure) (cons length structure))
#+END_SRC

上記のように変更した場合、下記のようにセレクタを変更するだけで良い
#+BEGIN_SRC scheme
;; selectors of a mobile
;; (define (left-branch mobile) (car mobile))  ;; これは変更不要
(define (right-branch mobile) (cdr mobile))

;; selectors of a branch
;; (define (branch-length branch) (car branch)) ;; これは変更不要
(define (branch-structure branch) (cdr branch))
#+END_SRC

*** 木に対するマップ

- mapに再帰を組み合わせたものは木を扱うための強力な抽象化になる

例) scale-tree
- 引数: 数値の係数と、葉が数値である木
- 返り値: 同じ形の木で、それぞれの数値が係数倍されたもの
実装
#+BEGIN_SRC scheme
(define (scale-tree tree factor)
  (cond ((null? tree) '())
        ((not (pair? tree)) (* tree factor))
        (else (cons (scale-tree (car tree) factor)
                    (scale-tree (cdr tree) factor)))))
(scale-tree (list 1 (list 2 (list 3 4) 5) (list 6 7)) 10)
> (10 (20 (30 40) 50) (60 70))
#+END_SRC

scale-treeの別実装
- 木を部分木の列とみなしてmapを使う
  - （各部分木の）列にマップを行い、それぞれの部分木を順番に係数倍し、
    結果のリストを返す
  - 木が葉である基本ケースでは単純に整数倍する
#+BEGIN_SRC scheme
;; 補助: map
(define (map proc items)
  (if (null? items)
      '()
      (cons (proc (car items))
            (map proc (cdr items)))))

(define (scale-tree tree factor)
  (map (lambda (sub-tree)
         (if (pair? sub-tree)
             (scale-tree sub-tree factor)
             (* sub-tree factor)))
       tree))
(scale-tree (list 1 (list 2 (list 3 4) 5) (list 6 7)) 10)
> (10 (20 (30 40) 50) (60 70))
#+END_SRC

*** 練習問題
**** 練習問題 2.30
#+BEGIN_SRC scheme
;; 直接的な実装
(define (square x) (* x x))
(define (square-tree tree)
  (cond ((null? tree) '())
        ((not (pair? tree)) (square tree))
        (else (cons (square-tree (car tree))
                    (square-tree (cdr tree))))))

;; mapを使う高階手続きでの実装
(define (square-tree tree)
  (map (lambda (sub-tree)
         (if (pair? sub-tree)
             (square-tree sub-tree)
             (square sub-tree)))
       tree))
#+END_SRC

動作確認
#+BEGIN_SRC scheme
;; 直接実装版
(square-tree (list 1 (list 2 (list 3 4) 5) (list 6 7))) ;; extect to (1 (4 (9 16) 25) (36 49))
> (1 (4 (9 16) 25) (36 49)) ;; OK

;; map版
(square-tree (list 1 (list 2 (list 3 4) 5) (list 6 7))) ;; extect to (1 (4 (9 16) 25) (36 49))
> (1 (4 (9 16) 25) (36 49)) ;; OK
#+END_SRC

**** 練習問題 2.31

#+BEGIN_SRC scheme
;; 直接実装版
(define (tree-map proc tree)
  (cond ((null? tree) '())
        ((not (pair? tree)) (proc tree))
        (else (cons (tree-map proc (car tree))
                    (tree-map proc (cdr tree))))))

;; map版
(define (tree-map proc tree)
  (map (lambda (sub-tree)
         (if (pair? sub-tree)
             (tree-map proc sub-tree)
             (proc sub-tree)))
       tree))

(define (square x) (* x x))
(define (square-tree tree) (tree-map square tree))
#+END_SRC

動作確認
#+BEGIN_SRC scheme
(square-tree (list 1 (list 2 (list 3 4) 5) (list 6 7))) ;; extect to (1 (4 (9 16) 25) (36 49))
> (1 (4 (9 16) 25) (36 49))

(square-tree (list (list 1 2) (list 3 4) 5 (list 6 (list 7 (list 8 9))))) ;; expected to ((1 4) (9 16) 25 (36 (49 (64 81))))
> ((1 4) (9 16) 25 (36 (49 (64 81))))
#+END_SRC

**** 練習問題 2.32

テンプレート
#+BEGIN_SRC scheme
(define (subsets s)
  (if (null? s)
      (list '())
      (let ((rest (subsets (cdr s))))
        (append rest (map <??> rest)))))
#+END_SRC

回答
#+BEGIN_SRC scheme
(define (subsets s)
  (if (null? s)
      (list '())
      (let ((rest (subsets (cdr s))))
        (append rest (map (lambda (x) (cons (car s) x)) rest)))))
#+END_SRC

動作確認
#+BEGIN_SRC scheme
(subsets (list 1))      ;; expected to (() (1))
> (() (1))
(subsets (list 1 2 3)) ;; expected to (() (3) (2) (2 3) (1) (1 3) (1 2) (1 2 3))
> (() (3) (2) (2 3) (1) (1 3) (1 2) (1 2 3))
#+END_SRC

なぜ動作するのかの説明
- ~(append rest (map <??> rest))~ の部分は、
  - restにまだ現れていない集合sの要素eについて、mapでrestの各要素（各要素自身もリスト）の先頭にeを加えたリストを生成し
  - それをrest（restにはeは存在していない）にappendしている
  - restは(cdr s)によりcdrダウンしながら再帰的に作られるので、restに含まれていない要素は必然的に(car s)になる
- そうすると、<??>の部分は、
  - (car s)をmapの第2引数であるrestの各要素リストの先頭に付け加えるための手続きであればよい
  - (car s)は再帰の度に変わるので以下のようにlambdaで都度都度手続きを生成して渡してやればよい
    #+BEGIN_SRC scheme
    (map (lambda (x) (cons (car s) x)) rest)
    #+END_SRC
* 2.2.3 標準インターフェースとしての例

- ここまでは複合データについて、データ抽象化により
  - データ表現の細かいところに煩わされずにプログラムを設計できる
  - 他の表現を実験する柔軟性を確保できる
ということを見てきた

この節ではデータ構造を扱う上での強力な設計原則である *標準インターフェー
ス (conventional interface)* を導入する

*例1: 木を引数にとり、奇数の葉の二乗の合計を計算する* (count-leaveと同じような仕組み)
#+BEGIN_SRC scheme
(define (sum-odd-squares tree)
  (cond ((null? tree) 0)
        ((not (pair? tree))
         (if (odd? tree) (square tree) 0))
        (else (+ (sum-odd-squares (car tree))
                 (sum-odd-squares (cdr tree))))))
#+END_SRC
*例2: 与えられた整数n以下のkについて、フィボナッチ数Fib(k)のうち偶数のもののリストを構築する*
#+BEGIN_SRC scheme
;; 
;; 
(define (even-fibs n)
  (define (next k)
    (if (> k n)
        nil
        (let ((f (fib k)))
          (if (even? f)
              (cons f (next (+ k 1)))
              (next (+ k 1))))))
  (next 0))
#+END_SRC

例1と例2の手続きは構造的には大きく違うが、2つの計算をより抽象的に記述
するととても似通っていることが分かる。

例1がしていることは、
- 木の葉を列挙し、
- フィルタによって奇数を選び、
- 選ばれた数の二乗を求め、
- + を使って、0から始めて結果を集積する

例2がしていることは、
- 0からnまでの数値を列挙し、
- それぞれの整数に対するフィボナッチ数を求め
- フィルタによって偶数を選び、
- consを使って、空リストから始めて結果を集積する

これらは図2.7のように信号処理におけるいくつかの段階を通る信号の流れとしてプロセスを概念化できる。
[[./img/sicp_2-2-3_001.png]]

ただし、残念ながら2つの例は信号の流れという構造を見せることができない。
どちらの手続きも、信号の流れという描写の中の要素に対応するはっきりとし
た部分というものがない。

信号の流れという構造が手続きの中で明確に見て取れるようにプログラムを構
成できれば、結果となるコードの概念的な明確さを高めることができるだろう。

** 列の演算

信号の流れという構造をより明確に反映するようにプログラムを構築するためのポイント
- 処理の中で各段階の間を流れる”信号”に集中する

例えば信号の流れ図中での *マップ* 段階は、map手続きを使って実装できる。
#+BEGIN_SRC scheme
(map square (list 1 2 3 4 5))
> (1 4 9 16 25)
#+END_SRC

列を *フィルタリング* するのは以下のようにすればよい
#+BEGIN_SRC scheme
(define (filter predicate sequence)
  (cond ((null? sequence) '())
        ((predicate (car sequence))
         (cons (car sequence)
               (filter predicate (cdr sequence))))
        (else (filter predicate (cdr sequence)))))

;; 動作例
(filter odd? (list 1 2 3 4 5))
> (1 3 5)
#+END_SRC
*[コメント]:* filter（mapもそうだが）はあくまでもフラットな列に対して
の手続きで定義されている。これらの手続きを処理するときは木構造の入力は
fringe等で単一のリストに変換する必要がある


*集積* は次のように実装できる。
#+BEGIN_SRC scheme
(define (accumulate op initial sequence)
  (if (null? sequence)
      initial
      (op (car sequence)
          (accumulate op initial (cdr sequence)))))

;; 動作例
(accumulate + 0 (list 1 2 3 4 5))
> 15
;; 置換モデルを確認
(+ 1 (+ 2 (+ 3 (+ 4 (+ 5 0)))))
(+ 1 (+ 2 (+ 3 (+ 4 5))))
(+ 1 (+ 2 (+ 3 9)))
(+ 1 (+ 2 12))
(+ 1 14)
15

(accumulate * 1 (list 1 2 3 4 5))
> 120

(accumulate cons '() (list 1 2 3 4 5))
> (1 2 3 4 5)
;; 置換モデルを確認
(cons 1 (cons 2 (cons 3 (cons 4 (cons 5 '()))))) ;; リストの定義そのもの
...
(1 2 3 4 5)
#+END_SRC

最後に処理する要素の列を *列挙* する。

- ~even-fib~ の場合
#+BEGIN_SRC scheme
;; 与えられた範囲の整数列を生成する
(define (enumerate-interval low high)
  (if (> low high)
      '()
      (cons low (enumerate-interval (+ low 1) high))))

(enumerate-interval 2 7)
> (2 3 4 5 6 7)
#+END_SRC

- 木の葉の列挙 (練習問題2.28のfringe手続きそのもの)
#+BEGIN_SRC scheme
(define (enumerate-tree tree)
  (cond ((null? tree) '())
        ((not (pair? tree)) (list tree))
        (else (append (enumerate-tree (car tree))
                      (enumerate-tree (cdr tree))))))

;; 動作例
(enumerate-tree (list 1 (list 2 (list 3 4)) 5))
>(1 2 3 4 5)
#+END_SRC

*** 信号の流れ図のような形での定式化

*sum-odd-squares*

#+BEGIN_SRC scheme
(define (sum-odd-squares tree)
   (accumulate
    + 0 (map square (filter odd? (enumerate-tree tree)))))

;; 動作例
(sum-odd-squares (list 1 (list 2 3) (list 4 5)))
> 35
#+END_SRC


*even-fibs*

#+BEGIN_SRC scheme
;; fibの定義
(define (fib n)
  (cond ((= 0 n) 0)
        ((= 1 n) 1)
        (else (+ (fib (- n 1)) (fib (- n 2))))))

(define (even-fibs n)
  (accumulate
   cons
   '()
   (filter even? (map fib (enumerate-interval 0 n)))))

;; 動作例
(even-fibs 10)
 > (0 2 8 34)
#+END_SRC

- プログラムを列の演算として表すことの利点はモジュール化された形でのプログラムの設計がやりやすくなること
- モジュール化とは比較的独立した部品を組み立ててプログラムを構築する設計のこと
- コンポーネントを柔軟に接続出来る標準インターフェースを提供することでモジュール化された設計を促すことが可能
- モジュールによる設計は工学の設計において複雑性をコントロールする強力な戦略
- 列の演算は自由に組み合わせられる標準的なプログラムの要素のライブラリを提供する

例1: 最初のn+1個のフィボナッチ数の二乗のリストを構築
#+BEGIN_SRC scheme
(define (list-fib-squares n)
  (accumulate
   cons
   '()
   (map square (map fib (enumerate-interval 0 n)))))

;; 動作例
(list-fib-squares 10)
#+END_SRC

例2: 性数列の中の奇数のものの二乗の積を計算
#+BEGIN_SRC scheme
(define (product-of-squares-of-odd-elements sequence)
  (accumulate * 1 (map square (filter odd? sequence))))

;; 動作例
(product-of-squares-of-odd-elements (list 1 2 3 4 5))
> 225
#+END_SRC

- ここでリストとして実装した列というのは、処理モジュールを接続できるようにする *標準インターフェース* として使うことができる

** 練習問題

*** 練習問題 2.33

#+BEGIN_SRC scheme
(define (map p sequence)
  (accumulate (lambda (x y) (cons (p x) y)) '() sequence))
(define (append seq1 seq2)
  (accumulate cons '() (enumerate-tree (list seq1 seq2))))
(define (length sequence)
  (accumulate (lambda (x y) (+ 1 y)) 0 sequence))
#+END_SRC

動作確認
#+BEGIN_SRC scheme
(map square (list 1 2 3 4 5)) ;; expected to (1 4 9 16 25)
(append (list 1 2 3) (list 4 5 6)) ;; expected to (1 2 3 4 5 6)
(length (list 1 2 3 4 5)) ;; expected to 5
#+END_SRC

*** 練習問題 2.34


*** 練習問題 2.35
*** 練習問題 2.36
*** 練習問題 2.37
*** 練習問題 2.38
*** 練習問題 2.39
