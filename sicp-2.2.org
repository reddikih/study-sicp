* 2.2 階層データと閉包性

- ペアは（このシステムでは？それとも普遍的に？）複合データオブジェクト
  を構築する基本的な糊となる
- 箱とポインタ記法 (/box-and-pointer notation/)
  - それぞれのオブジェクトは箱へのポインタとして表される
  - 基本（データの）オブジェクトの箱にはオブジェクトの表現（数値なら数
    字等）が入っている
- 図2.2の例
  - (cons 1 2) で作られるペアを表している
  - ペアの箱は実際には2つの箱で、左の箱にはペアのcarへのポインタが入り、
    右の箱にはペアのcdrへのポインタが入る
- *consの閉包性 (closure property)*
  - ペアを要素とするペアを作る能力
- 一般的に、データオブジェクトを組み合わせる操作は、その演算による組み
  合わせの結果自身が、同じ演算によって組み合わせることができるのであれ
  ば、閉包性を満たす
- 閉包によって *階層(hierarchical)* 構造 -- 部品によって作られ、その部
  品もまた部品よって作られ…という構造 -- を作ることが可能になる

* 2.2.1 列の表現

- ペアを使って構築できる便利な構造の一つは *列(sequence)*
  - 列とはデータオブジェクトの順序付き集合
- 図2.4は素直な表現方法の一つを示している
  - 1,2,3,4の列はペアのチェーンとして表される
  - 最後のペアのcdrはペアではない特別な値を指すことで列の終端であるこ
    とを伝える
    - 箱ポインタ図では斜線で表され、プログラムでは変数nilという値で表
      される
      - *(引田コメント):* nilは変数？
  #+BEGIN_SRC scheme
  ;; 図2.4をプログラムで表現する
  (cons 1 (cons 2 (cons 3 (cons 4 nil))))
  #+END_SRC
- 入れ子のconsによって作られるペアの列は *リスト(/list/)* と呼ばれる
  - 図2.4の例は ~(list 1 2 3 4)~ によって生成できる。

listの構文
#+BEGIN_SRC scheme
(list <a1> <a2> ... <an>)

;; は以下と等価
(cons <a1> (cons <a2> (cons ... (cons <an> nil) ... )))
#+END_SRC

#+BEGIN_SRC scheme
(define one-through-four (list 1 2 3 4))
one-through-four
(1 2 3 4)
#+END_SRC

- carはリストの最初の項を選択し、cdrは最初の項以外の全てからなる部分リ
  ストを選択するものと考えられる
- carとcdrを入れ子にしていくとリストの任意の項を取得できる
- コンストラクタconsは元のリストと同じリストに最初に一つ項が加わったものを作る
#+BEGIN_SRC scheme
(car one-through-four)
1
(cdr one-through-four)
(2 3 4)
(car (cdr one-through-four))
2
(cons 10 one-through-four)
(10 1 2 3 4)
(cons 5 one-through-four)
(5 1 2 3 4)
#+END_SRC

- *nil* は要素のない列、すなわち *空リスト(/empty list/)* と考えること
  もできる

** リスト演算

*cdrダウン* : 確率されたプログラミングテクニック
 
- *例1) list-ref* list-ref手続きは引数としてリストと数値nを取り、リス
  トのn番目のものを返す
  - n = 0 であれば、list-refはリストのcarを返す
  - そうでなければ、list-refはリストのcdrの(n-1)番目のものを返す
#+BEGIN_SRC scheme
(define (list-ref items n)
  (if (= n 0)
      (car items)
      (list-ref (cdr items) (- n 1))))

(define squares (list 1 4 9 16 25))
(list-ref squares 3)
;; 16
#+END_SRC

- リスト全体をcdrダウンするために、Schemeは基本述語null?を持っている
  - null?は、引数が空リストかどうかテストするもの

- *例2) length* lenghtはリストの要素数を返す手続き
#+BEGIN_SRC scheme
;; 再帰プロセス
(define (lenght items)
  (if (null? items)
      0
      (+ 1 (length (cdr items)))))

(define odds (list 1 3 5 7))
(length odds)
;; 4
#+END_SRC

- lengthの反復プロセススタイル
#+BEGIN_SRC scheme
(define (length items)
  (define (length-iter a count)
    (if (null? a)
        count
        (length-iter (cdr a) (+ 1 count))))
  (length-iter items 0))
#+END_SRC


*consアップ* もう一つの確率されたプログラミングテクニック

- *例3) append* appendは2つのリストを引数として取り、要素を連結して新しいリストを作る
- appendの再帰計画
  - もしlist1が空リストであれば、結果は単にlist2である
  - そうでなければ、list1のcdrとlist2をappendし、その結果にlist1のcarをconsする
#+BEGIN_SRC scheme
(define (append list1 list2)
  (if (null? list1)
      list2
      (cons (car list1) (append (cdr list1) list2))))
#+END_SRC

動作確認
#+BEGIN_SRC scheme
(append squares odds)
> (1 4 9 16 25 1 3 5 7)
(append odds squares)
> (1 3 5 7 1 4 9 16 25)
#+END_SRC

** 練習問題
*** 練習問題 2.17

#+BEGIN_SRC scheme
(define (last-pair items)
  (if (null? (cdr items))
      items    ;; required by gauche. "nil" cannot be used in it.
      (last-pair (cdr items))))
#+END_SRC

動作確認
#+BEGIN_SRC scheme
(last-pair (list 23 72 149 34))
;; (34)
#+END_SRC

*** 練習問題 2.18

#+BEGIN_SRC scheme
(define (reverse items)
  (define (iter src dest)
    (if (null? src)
        dest
        (iter (cdr src) (cons (car src) dest))))
  (iter items '()))
#+END_SRC

動作確認
#+BEGIN_SRC scheme
(reverse (list 1 4 9 16 25))
;; (25 16 9 4 1)
#+END_SRC

*** 練習問題 2.19
TBD
*** 練習問題 2.20

*ドット末尾記法 (dotted-tail notation)* は覚えておくこと

回答
#+BEGIN_SRC scheme
(define (same-parity base . rest)
  (define (check-and-add b target chain)
    (if (eq? (odd? b) (odd? target))
        (cons chain target)
        chain))
  (define (iter src result)
    (if (null? src)
        result
        (iter (cdr src) (check-and-add base (car src) result))))
  (iter rest (cons base '())))
#+END_SRC

動作確認
#+BEGIN_SRC 
(same-parity 1 2 3 4 5 6 7 8)
(same-parity 2 3 4 5 6 7 8)
#+END_SRC

練習
#+BEGIN_SRC scheme
(define (g . w) w)
(g 1 2 3)
;; (1 2 3)
(g)
;; () ;; 0個以上の引数に対応する。引数が0個の場合は空リストを返す
#+END_SRC



** リストに対するマップ

- 非常に便利な演算としてリストのそれぞれの要素に何らかの変換を適用し、
  結果のリストを返すというものがある

*例) scale-list* scale-listは、与えられた係数をリストの其々の数値にかける
#+BEGIN_SRC scheme
(define (scale-list items factor)
  (if (null? items)
      '() ;; for gauche
      (cons (* (car items) factor)
            (scale-list (cdr items) factor))))
;; 動作確認
(scale-list (list 1 2 3 4 5) 10)
#+END_SRC

この一般的な考え方を抽象化し、mapとよばれる高階手続きによって表現され
る共通パターンとして捉えることができる。

mapは、1引数の手続きとリストを引数としてとり、リストのそれぞれの要素に
手続きを適用した結果のリストを返す。

#+BEGIN_SRC scheme
(define (map proc items)
  (if (null? items)
      '()
      (cons (proc (car items))
            (map proc (cdr items)))))
;; 動作例
(map abs (list -10 2.5 -11.6 17))
; (10 2.5 11.6 17)
(map (lambda (x) (* x x)) (list 1 2 3 4))
; (1 4 9 16)
#+END_SRC

mapを使ってscale-listの新しい定義を書ける。
#+BEGIN_SRC scheme
(define (scale-list items factor)
  (map (lambda (x) (* x factor)) items))
#+END_SRC

- mapはリストを扱ううえでのより高いレベルの抽象化を達成する。
- mapはリストを変形する手続きの実装を、リストの要素をどうやって取り出
  して結合していくかという細かいところから切り離す *抽象化の壁* を作る
  ことを助けてくれる

** 練習問題
*** 練習問題 2.21
1つ目のsquare-listの定義
#+BEGIN_SRC scheme
(define (square x) (* x x))
(define (square-list items)
  (if (null? items)
      '() ;; for gauche
      (cons (square (car items)) (square-list (cdr items)))))
#+END_SRC

2つ目のsquare-listの定義
#+BEGIN_SRC scheme
(define (square-list items)
  (map square items))
#+END_SRC

動作チェック
#+BEGIN_SRC scheme
(square-list (list 1 2 3 4))
#+END_SRC

*** 練習問題 2.22

#+BEGIN_SRC scheme
(define (square-list items)
  (define (iter things answer)
    (if (null? things)
        answer
        (iter (cdr things)
              (cons (square (car things))
                    answer))))
  (iter items '()))

;; 動作確認: 逆順になってしまう
(square-list (list 1 2 3 4))
> (16 9 4 1) 
#+END_SRC

逆順になってしまう理由
- インタプリタが適用順序評価なので、iter呼び出し時の第2引数のconsはさきに計算される
- 次にiterを実行したとき、answerに一つ前のiteration時のcarの値でペアが作られている
  - 現在のiteration時の(car things)の後ろに一つ前までのリスト（ペアの
    ネスト構造）が追加されている
置換モデルでiterationの部分のみを抜き出してみると以下のような動きになる
#+BEGIN_SRC scheme
(square-list (list 1 2 3 4))
(square-list (1 2 3 4))
...
(iter (2 3 4) (cons 1 '()))
(iter (3 4) (cons 4 (cons 1 '())))
(iter (4) (cons 9 (cons 4 (cons 1 '()))))
(iter '() (cons 16 (cons 9 (cons 4 (cons 1 '())))))
(cons 16 (cons 9 (cons 4 (cons 1 '()))))
(16 9 4 1)
#+END_SRC
  
#+BEGIN_SRC scheme
;; consの引数を逆にしたバージョン。これも上手くいかない
(define (square-list items)
  (define (iter things answer)
    (if (null? things)
        answer
        (iter (cdr things)
              (cons answer
                    (square (car things))))))
  (iter items '()))

;; 動作確認。リストにならない
(square-list (list 1 2 3 4))
> ((((() . 1) . 4) . 9) . 16)
#+END_SRC

consの引数を逆にしても上手くいかない理由
- これもiter呼び出し時のconsは適用順序評価なので先に評価される
- listはペアの連鎖であり、各ペアのcarがリストの要素値でconsは次のリス
  ト要素であるペアへのポインタか、リストの末尾を表す空リスト'()のいず
  れかでなければならない。
- このプログラムではconsでcarには一つ前のiterationまでの結果を指定し、
  cdrには当該iterationにおけるリストのcarを付けているので、このペアは
  リストにはならない
置換モデルでiterationの部分のみを抜き出してみると以下のような動きになる
#+BEGIN_SRC scheme
(square-list (list 1 2 3 4))
(square-list (1 2 3 4))
...
(iter (2 3 4) (cons '() 1))
(iter (3 4) (cons (cons '() 1) 4))
(iter (4) (cons (cons (cons '() 1) 4) 9))
(iter '()) (cons (cons (cons (cons '() 1) 4) 9) 16))
(cons (cons (cons (cons '() 1) 4) 9) 16)
((((() . 1) . 4) . 9) . 16)
#+END_SRC


*** 練習問題 2.23

* 2.2.2 階層構造

- リストによる列の表現は、要素がそれ自身列であるような列を表現するよう
  に一般化できる
- ((1 2) 3 4)は、 ~(cons (list 1 2) (list 3 4))~ のように3つの項目を持
  つリストとして見ることが出来る
  - 1つ目の項目はそれ自身が (1 2) というリストということになる
  - 図2.5はこのリストのペアによる表現
- 要素が列であるような列は *木(tree)* として考えることが出来る
  - 列の要素: 木の枝
  - それ自身が列である要素は部分木
- 再帰は木構造を扱う自然なツール
  - 木への演算をその枝に対する演算に縮約
  - 枝の枝に対する演算に縮約... と続けていくことで木の葉にたどり着く
- 例) 2.2.1節の length手続きと木の葉の総数を返すcount-leaves手続きの比較
#+BEGIN_SRC scheme
;; length手続き from 2.2.2
(define (lenght items)
  (if (null? items)
      0
      (+ 1 (length (cdr items)))))

(define x (cons (list 1 2) (list 3 4)))
(length x)
3
(count-leaves x) ;; 今の時点では未実装
4
#+END_SRC

- lengthの再帰計画
  - リストxのlegnthは、xのcdrのlengthに1を足した値である
  - 空リストのlengthは0である
- count-leavesの再帰計画
  - 空リストのcount-leavesは0である
  - 葉のcount-leavesは1である
  - 木xのcount-leavesは、xのcarのcount-leavesとxのcdrのcount-leavesを足した値である

木に対する再帰手続きが書きやすくなるようにschemeでは ~pair?~ という基
本述語を提供している。pairは引数がペアであるかどうかテストする。

以下はcount-leavesの実装
#+BEGIN_SRC scheme
(define (count-leaves x)
  (cond ((null? x) 0)                       ;; - 空リストのcount-leavesは0である
        ((not (pair? x)) 1)                 ;; - 葉のcount-leavesは1である
        (else (+ (count-leaves (car x))     ;; - 木xのcount-leavesは、xのcarのcount-leavesと
                 (count-leaves (cdr x)))))) ;;   xのcdrのcount-leavesを足した値である
#+END_SRC

動作確認
#+BEGIN_SRC scheme
(define x (cons (list 1 2) (list 3 4)))
(count-leaves x)
;; 4
(list x x)
(length (list x x))
;; 2
(count-leaves (list x x))
;; 8
#+END_SRC

*** 練習問題
**** 練習問題 2.24
式: (list 1 (list 2 (list 3 4)))

インタプリタの表示結果
#+BEGIN_SRC scheme
;; gosh
(list 1 (list 2 (list 3 4)))
;; -> (1 (2 (3 4)))
#+END_SRC

箱-点構造図
[[./img/sicp_2-2-2_ex2-24_01.png]]

木の表現
[[./img/sicp_2-2-2_ex2-24_02.png]]

**** 練習問題 2.25
#+BEGIN_SRC scheme
;; (1 3 (5 7) 9) から7を取り出す
(define x (list 1 3 (list 5 7) 9))
(car (cdr (car (cdr (cdr x)))))

;; ((7))
(define x (list (list 7)))
(car (car x))

;; (1 (2 (3 (4 (5 (6 7))))))
(define x (list 1 (list 2 (list 3 (list 4 (list 5 (list 6 7)))))))
(car (cdr (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr x))))))))))))
#+END_SRC

**** 練習問題 2.26
#+BEGIN_SRC scheme
;; append
(define (append list1 list2)
  (if (null? list1)
      list2
      (cons (car list1) (append (cdr list1) list2))))
#+END_SRC

#+BEGIN_SRC scheme
(define x (list 1 2 3))
(define y (list 4 5 6))

(append x y) ;; (1 2 3 4 5 6)
(cons x y)   ;; ((1 2 3) 4 5 6)
(list x y)   ;; ((1 2 3) (4 5 6))
#+END_SRC

**** 練習問題 2.27

回答
#+BEGIN_SRC scheme
(define (deep-reverse items)
  (define (iter src dest)
    (if (null? src)
        dest
        (iter (cdr src) (cons (if (pair? (car src)) ;; この(car src)はlet使ってローカル変数にできそう
                                  (deep-reverse (car src))
                                  (car src))
                              dest))))
  (iter items '()))
#+END_SRC

動作確認
#+BEGIN_SRC scheme
;; (1 2 3 4) -> (4 3 2 1)
(define x (list 1 2 3 4))
(deep-reverse x)
gosh> (4 3 2 1)

;; ((1 2) (3 4)) -> ((4 3) (2 1))
(define y (list (list 1 2) (list 3 4)))
(deep-reverse y)
gosh> ((4 3) (2 1))

;; (1 (2 3 (4 5)) ((6 7) (8 9))) -> (((9 8) (7 6)) ((5 4) 3 2) 1)
(define z (list 1 (list 2 3 (list 4 5)) (list (list 6 7) (list 8 9))))
(deep-reverse z)
gosh> (((9 8) (7 6)) ((5 4) 3 2) 1)
#+END_SRC

**** 練習問題 2.28

練習: 葉の値を表示する
#+BEGIN_SRC scheme
;; 練習: disp-leaves: display leaves
(define (disp-leaves x)
  (cond ((null? x) (display '()))
        ((not (pair? x)) (display x))
        (else (begin (disp-leaves (car x))
                     (disp-leaves (cdr x))))))

(disp-leaves (list 1 2 3 4))
(disp-leaves (list (list 1 2) (list 3 4)))
#+END_SRC

回答
#+BEGIN_SRC scheme
;; 補助関数
(define (append list1 list2)
  (if (null? list1)
      list2
      (cons (car list1) (append (cdr list1) list2))))

;; ボツ回答1
(define (fringe x)
  (cond ((not (pair? x)) (cons x '()))
        ((null? (cdr x)) x)
        (else (append (fringe (car x))
                      (fringe (cdr x))))))

;; ボツ回答2
(define (fringe x)
  (cond ((null? x) '())
        ((not (pair? x)) x)
        (else (cons (if (pair? (car x))
                        (fringe (car x))
                        (car x))
                    (fringe (cdr x))))))

;; ボツ回答3. 実行時エラー
(define (fringe x)
  (define (iter src dest)
    (cond ((null? src) dest)
          ((not (pair? src)) src))
	  (else (iter (cdr src) (cons (if (pair? (car src))
                                          (iter (car src) dest)
                                          (car src)))))))
  (iter x '()))

;; ボツ回答4. 実行時エラー
(define (fringe x)
  (cond ((null? x) '())
        ((not (pair? x)) x)
        (else (if (pair? (car x))
                  (cons (fringe (car x)) (fringe (cdr x)))
                  (car x))
               (fringe (cdr x)))))

;; ボツ回答5. リストは作れているがreverseしてしまっている
(define (fringe x)
  (define (iter src dest)
    (if (null? src)
        dest
        (iter (cdr src) (append (if (pair? (car src))
                                    (fringe (car src))
                                    (cons (car src) '()))
                                dest))))
  (iter x '()))

;; 回答6. ボツ回答のappendの引数を逆に変更
(define (fringe x)
  (define (iter src dest)
    (if (null? src)
        dest
        (iter (cdr src)
              (append dest
                      (if (pair? (car src))
                          (fringe (car src))
                          (cons (car src) '()))))))
  (iter x '()))
#+END_SRC

動作確認
#+BEGIN_SRC scheme
(fringe (list 1))                     ;; expect to (1)
> (1)
(fringe (list 1 2 3 4))               ;; expect to (1 2 3 4)
> (1 2 3 4)
(fringe (list (list 1 2) (list 3 4))) ;; expect to (1 2 3 4)
> (1 2 3 4)
(fringe (list (list 1 2) 3))          ;; expect to (1 2 3)
> (1 2 3)

(define x (list (list 1 2) (list 3 4))) ;; expect to (1 2 3 4 1 2 3 4)
(fringe (list x x))
> (1 2 3 4 1 2 3 4)
#+END_SRC

**** 練習問題 2.29

#+BEGIN_SRC scheme
(define (make-mobile left right) (list left right))
(define (make-branch length structure) (list length structure))
#+END_SRC

***** a. セレクタと枝の構成要素を返す手続き
#+BEGIN_SRC scheme
;; selectors of a mobile
(define (left-branch mobile) (car mobile))
(define (right-branch mobile) (car (cdr mobile)))

;; selectors of a branch
(define (branch-length branch) (car branch))
(define (branch-structure branch) (car (cdr branch)))
#+END_SRC

***** b. モビールの総重量を返す手続き: total-weight
#+BEGIN_SRC scheme
(define (total-weight mobile)
  (+ (branch-weight (left-branch mobile))
     (branch-weight (right-branch mobile))))

(define (branch-weight branch)
  (let ((struct (branch-structure branch)))
    (cond ((null? struct) 0) ;; このケースがあり得るのかは不明
          ((not (pair? struct)) struct)
          (else (total-weight struct)))))
#+END_SRC

動作確認
#+BEGIN_SRC scheme
(define m1 (make-mobile (make-branch 1 2)
                        (make-branch 3 4)))
(define m2 (make-mobile (make-branch 2 5)
                        (make-branch 2 6)))
(define m3 (make-mobile (make-branch 3 4)
                        (make-branch 3 7)))
(define m4 (make-mobile (make-branch 4 m2)
                        (make-branch 4 m3)))
(define m5 (make-mobile (make-branch 5 m1)
                        (make-branch 5 m4)))
(total-weight m1) ;; expected to 6
> 6
(total-weight m2) ;; expected to 11
> 11
(total-weight m4) ;; expected to m2:11 + m3:11 = 22
> 22
(total-weight m5) ;; expected to m1:6 + m4:22 = 28
> 28
#+END_SRC

***** c. バランスが取れているかのテスト

#+BEGIN_SRC scheme
(define (balanced? mobile)
  (and (eq? (branch-torque (left-branch mobile))
            (branch-torque (right-branch mobile)))
       (branch-balanced? (left-branch mobile))
       (branch-balanced? (right-branch mobile))))

(define (branch-torque branch)
  (* (branch-length branch)
     (branch-weight branch)))

(define (branch-balanced? branch)
  (let ((struct (branch-structure branch)))
    (cond ((null? struct) #t)
          ((not (pair? struct)) #t)
          (else (balanced? struct)))))
#+END_SRC

動作確認
#+BEGIN_SRC scheme
(define b1 (make-branch 2 4))
(define b2 (make-branch 4 2))
(define b3 (make-branch 3 5))
(define b4 (make-branch 10 3))
(define m1 (make-mobile b1 b2))
(define m2 (make-mobile b1 b3))
(define b5 (make-branch 5 m1))
(define m3 (make-mobile b4 b5))

(balanced? m1) ;; expected to true
> #t
(balanced? m2) ;; expected to false
> #f
(balanced? m3) ;; expected to true
> #t

(define b11 (make-branch 7 5))
(define b12 (make-branch 5 (make-mobile (make-branch 2 4)
                                        (make-branch 2 3))))
(define m10 (make-mobile b11 b12))

(balanced? m10) ;; expected to false
> #f
#+END_SRC

***** d. モビールの表現を変更したときのプログラム変更の影響度合い

変更内容: モビールと枝のデータ構造をリストではなくconsに変更
#+BEGIN_SRC scheme
(define (make-mobile left right) (cons left right))
(define (make-branch length structure) (cons length structure))
#+END_SRC

上記のように変更した場合、下記のようにセレクタを変更するだけで良い
#+BEGIN_SRC scheme
;; selectors of a mobile
;; (define (left-branch mobile) (car mobile))  ;; これは変更不要
(define (right-branch mobile) (cdr mobile))

;; selectors of a branch
;; (define (branch-length branch) (car branch)) ;; これは変更不要
(define (branch-structure branch) (cdr branch))
#+END_SRC

*** 木に対するマップ

- mapに再帰を組み合わせたものは木を扱うための強力な抽象化になる

例) scale-tree
- 引数: 数値の係数と、葉が数値である木
- 返り値: 同じ形の木で、それぞれの数値が係数倍されたもの
実装
#+BEGIN_SRC scheme
(define (scale-tree tree factor)
  (cond ((null? tree) '())
        ((not (pair? tree)) (* tree factor))
        (else (cons (scale-tree (car tree) factor)
                    (scale-tree (cdr tree) factor)))))
(scale-tree (list 1 (list 2 (list 3 4) 5) (list 6 7)) 10)
> (10 (20 (30 40) 50) (60 70))
#+END_SRC

scale-treeの別実装
- 木を部分木の列とみなしてmapを使う
  - （各部分木の）列にマップを行い、それぞれの部分木を順番に係数倍し、
    結果のリストを返す
  - 木が葉である基本ケースでは単純に整数倍する
#+BEGIN_SRC scheme
;; 補助: map
(define (map proc items)
  (if (null? items)
      '()
      (cons (proc (car items))
            (map proc (cdr items)))))

(define (scale-tree tree factor)
  (map (lambda (sub-tree)
         (if (pair? sub-tree)
             (scale-tree sub-tree factor)
             (* sub-tree factor)))
       tree))
(scale-tree (list 1 (list 2 (list 3 4) 5) (list 6 7)) 10)
> (10 (20 (30 40) 50) (60 70))
#+END_SRC

*** 練習問題
**** 練習問題 2.30
#+BEGIN_SRC scheme
;; 直接的な実装
(define (square x) (* x x))
(define (square-tree tree)
  (cond ((null? tree) '())
        ((not (pair? tree)) (square tree))
        (else (cons (square-tree (car tree))
                    (square-tree (cdr tree))))))

;; mapを使う高階手続きでの実装
(define (square-tree tree)
  (map (lambda (sub-tree)
         (if (pair? sub-tree)
             (square-tree sub-tree)
             (square sub-tree)))
       tree))
#+END_SRC

動作確認
#+BEGIN_SRC scheme
;; 直接実装版
(square-tree (list 1 (list 2 (list 3 4) 5) (list 6 7))) ;; extect to (1 (4 (9 16) 25) (36 49))
> (1 (4 (9 16) 25) (36 49)) ;; OK

;; map版
(square-tree (list 1 (list 2 (list 3 4) 5) (list 6 7))) ;; extect to (1 (4 (9 16) 25) (36 49))
> (1 (4 (9 16) 25) (36 49)) ;; OK
#+END_SRC

**** 練習問題 2.31

#+BEGIN_SRC scheme
;; 直接実装版
(define (tree-map proc tree)
  (cond ((null? tree) '())
        ((not (pair? tree)) (proc tree))
        (else (cons (tree-map proc (car tree))
                    (tree-map proc (cdr tree))))))

;; map版
(define (tree-map proc tree)
  (map (lambda (sub-tree)
         (if (pair? sub-tree)
             (tree-map proc sub-tree)
             (proc sub-tree)))
       tree))

(define (square x) (* x x))
(define (square-tree tree) (tree-map square tree))
#+END_SRC

動作確認
#+BEGIN_SRC scheme
(square-tree (list 1 (list 2 (list 3 4) 5) (list 6 7))) ;; extect to (1 (4 (9 16) 25) (36 49))
> (1 (4 (9 16) 25) (36 49))

(square-tree (list (list 1 2) (list 3 4) 5 (list 6 (list 7 (list 8 9))))) ;; expected to ((1 4) (9 16) 25 (36 (49 (64 81))))
> ((1 4) (9 16) 25 (36 (49 (64 81))))
#+END_SRC

**** 練習問題 2.32

テンプレート
#+BEGIN_SRC scheme
(define (subsets s)
  (if (null? s)
      (list '())
      (let ((rest (subsets (cdr s))))
        (append rest (map <??> rest)))))
#+END_SRC

回答
#+BEGIN_SRC scheme
(define (subsets s)
  (if (null? s)
      (list '())
      (let ((rest (subsets (cdr s))))
        (append rest (map (lambda (x) (cons (car s) x)) rest)))))
#+END_SRC

動作確認
#+BEGIN_SRC scheme
(subsets (list 1))      ;; expected to (() (1))
> (() (1))
(subsets (list 1 2 3)) ;; expected to (() (3) (2) (2 3) (1) (1 3) (1 2) (1 2 3))
> (() (3) (2) (2 3) (1) (1 3) (1 2) (1 2 3))
#+END_SRC

なぜ動作するのかの説明
- ~(append rest (map <??> rest))~ の部分は、
  - restにまだ現れていない集合sの要素eについて、mapでrestの各要素（各要素自身もリスト）の先頭にeを加えたリストを生成し
  - それをrest（restにはeは存在していない）にappendしている
  - restは(cdr s)によりcdrダウンしながら再帰的に作られるので、restに含まれていない要素は必然的に(car s)になる
- そうすると、<??>の部分は、
  - (car s)をmapの第2引数であるrestの各要素リストの先頭に付け加えるための手続きであればよい
  - (car s)は再帰の度に変わるので以下のようにlambdaで都度都度手続きを生成して渡してやればよい
    #+BEGIN_SRC scheme
    (map (lambda (x) (cons (car s) x)) rest)
    #+END_SRC
* 2.2.3 標準インターフェースとしての例

- ここまでは複合データについて、データ抽象化により
  - データ表現の細かいところに煩わされずにプログラムを設計できる
  - 他の表現を実験する柔軟性を確保できる
ということを見てきた

この節ではデータ構造を扱う上での強力な設計原則である *標準インターフェー
ス (conventional interface)* を導入する

*例1: 木を引数にとり、奇数の葉の二乗の合計を計算する* (count-leaveと同じような仕組み)
#+BEGIN_SRC scheme
(define (sum-odd-squares tree)
  (cond ((null? tree) 0)
        ((not (pair? tree))
         (if (odd? tree) (square tree) 0))
        (else (+ (sum-odd-squares (car tree))
                 (sum-odd-squares (cdr tree))))))
#+END_SRC
*例2: 与えられた整数n以下のkについて、フィボナッチ数Fib(k)のうち偶数のもののリストを構築する*
#+BEGIN_SRC scheme
;; 
;; 
(define (even-fibs n)
  (define (next k)
    (if (> k n)
        nil
        (let ((f (fib k)))
          (if (even? f)
              (cons f (next (+ k 1)))
              (next (+ k 1))))))
  (next 0))
#+END_SRC

例1と例2の手続きは構造的には大きく違うが、2つの計算をより抽象的に記述
するととても似通っていることが分かる。

例1がしていることは、
- 木の葉を列挙し、
- フィルタによって奇数を選び、
- 選ばれた数の二乗を求め、
- + を使って、0から始めて結果を集積する

例2がしていることは、
- 0からnまでの数値を列挙し、
- それぞれの整数に対するフィボナッチ数を求め
- フィルタによって偶数を選び、
- consを使って、空リストから始めて結果を集積する

これらは図2.7のように信号処理におけるいくつかの段階を通る信号の流れとしてプロセスを概念化できる。
[[./img/sicp_2-2-3_001.png]]

ただし、残念ながら2つの例は信号の流れという構造を見せることができない。
どちらの手続きも、信号の流れという描写の中の要素に対応するはっきりとし
た部分というものがない。

信号の流れという構造が手続きの中で明確に見て取れるようにプログラムを構
成できれば、結果となるコードの概念的な明確さを高めることができるだろう。

*列の演算*

信号の流れという構造をより明確に反映するようにプログラムを構築するためのポイント
- 処理の中で各段階の間を流れる”信号”に集中する

例えば信号の流れ図中での *マップ* 段階は、map手続きを使って実装できる。
#+BEGIN_SRC scheme
(map square (list 1 2 3 4 5))
> (1 4 9 16 25)
#+END_SRC

列を *フィルタリング* するのは以下のようにすればよい
#+BEGIN_SRC scheme
(define (filter predicate sequence)
  (cond ((null? sequence) '())
        ((predicate (car sequence))
         (cons (car sequence)
               (filter predicate (cdr sequence))))
        (else (filter predicate (cdr sequence)))))

;; 動作例
(filter odd? (list 1 2 3 4 5))
> (1 3 5)
#+END_SRC
*[コメント]:* filter（mapもそうだが）はあくまでもフラットな列に対して
の手続きで定義されている。これらの手続きを処理するときは木構造の入力は
fringe等で単一のリストに変換する必要がある


*集積* は次のように実装できる。
#+BEGIN_SRC scheme
(define (accumulate op initial sequence)
  (if (null? sequence)
      initial
      (op (car sequence)
          (accumulate op initial (cdr sequence)))))

;; 動作例
(accumulate + 0 (list 1 2 3 4 5))
> 15
;; 置換モデルを確認
(+ 1 (+ 2 (+ 3 (+ 4 (+ 5 0)))))
(+ 1 (+ 2 (+ 3 (+ 4 5))))
(+ 1 (+ 2 (+ 3 9)))
(+ 1 (+ 2 12))
(+ 1 14)
15

(accumulate * 1 (list 1 2 3 4 5))
> 120

(accumulate cons '() (list 1 2 3 4 5))
> (1 2 3 4 5)
;; 置換モデルを確認
(cons 1 (cons 2 (cons 3 (cons 4 (cons 5 '()))))) ;; リストの定義そのもの
...
(1 2 3 4 5)
#+END_SRC

最後に処理する要素の列を *列挙* する。

- ~even-fib~ の場合
#+BEGIN_SRC scheme
;; 与えられた範囲の整数列を生成する
(define (enumerate-interval low high)
  (if (> low high)
      '()
      (cons low (enumerate-interval (+ low 1) high))))
      
(enumerate-interval 2 7)
> (2 3 4 5 6 7)
#+END_SRC

- 木の葉の列挙 (練習問題2.28のfringe手続きそのもの)
#+BEGIN_SRC scheme
(define (enumerate-tree tree)
  (cond ((null? tree) '())
        ((not (pair? tree)) (list tree))
        (else (append (enumerate-tree (car tree))
                      (enumerate-tree (cdr tree))))))

;; 動作例
(enumerate-tree (list 1 (list 2 (list 3 4)) 5))
>(1 2 3 4 5)
#+END_SRC

*信号の流れ図のような形での定式化*

*sum-odd-squares*

#+BEGIN_SRC scheme
(define (sum-odd-squares tree)
   (accumulate
    + 0 (map square (filter odd? (enumerate-tree tree)))))

;; 動作例
(sum-odd-squares (list 1 (list 2 3) (list 4 5)))
> 35
#+END_SRC


*even-fibs*

#+BEGIN_SRC scheme
;; fibの定義
(define (fib n)
  (cond ((= 0 n) 0)
        ((= 1 n) 1)
        (else (+ (fib (- n 1)) (fib (- n 2))))))

(define (even-fibs n)
  (accumulate
   cons
   '()
   (filter even? (map fib (enumerate-interval 0 n)))))

;; 動作例
(even-fibs 10)
 > (0 2 8 34)
#+END_SRC

- プログラムを列の演算として表すことの利点はモジュール化された形でのプログラムの設計がやりやすくなること
- モジュール化とは比較的独立した部品を組み立ててプログラムを構築する設計のこと
- コンポーネントを柔軟に接続出来る標準インターフェースを提供することでモジュール化された設計を促すことが可能
- モジュールによる設計は工学の設計において複雑性をコントロールする強力な戦略
- 列の演算は自由に組み合わせられる標準的なプログラムの要素のライブラリを提供する

例1: 最初のn+1個のフィボナッチ数の二乗のリストを構築
#+BEGIN_SRC scheme
(define (list-fib-squares n)
  (accumulate
   cons
   '()
   (map square (map fib (enumerate-interval 0 n)))))

;; 動作例
(list-fib-squares 10)
> (0 1 1 4 9 25 64 169 441 1156 3025)
#+END_SRC

例2: 性数列の中の奇数のものの二乗の積を計算
#+BEGIN_SRC scheme
(define (product-of-squares-of-odd-elements sequence)
  (accumulate * 1 (map square (filter odd? sequence))))

;; 動作例
(product-of-squares-of-odd-elements (list 1 2 3 4 5))
> 225
#+END_SRC

- ここでリストとして実装した列というのは、処理モジュールを接続できるようにする *標準インターフェース* として使うことができる

** 練習問題

*** 練習問題 2.33

#+BEGIN_SRC scheme
  (define (map p sequence)
    (accumulate (lambda (x y) (cons (p x) y)) '() sequence))
  (define (append seq1 seq2)
    (accumulate cons '() (enumerate-tree (list seq1 seq2))))
  ;; 時田さんバージョン
  (define (append seq1 seq2)
    (accumulate cons seq2 seq1))
  (define (length sequence)
    (accumulate (lambda (x y) (+ 1 y)) 0 sequence))
#+END_SRC

動作確認
#+BEGIN_SRC scheme
(map square (list 1 2 3 4 5)) ;; expected to (1 4 9 16 25)
(append (list 1 2 3) (list 4 5 6)) ;; expected to (1 2 3 4 5 6)
(length (list 1 2 3 4 5)) ;; expected to 5
#+END_SRC

*** 練習問題 2.34

ホーナー法のひながた
#+BEGIN_SRC scheme
(define (horner-eval x coefficient-sequence)
  (accumulate (lambda (this-coeff higher-terms) <??>)
              0
              coefficient-sequence))
#+END_SRC

回答
#+BEGIN_SRC scheme
(define (horner-eval x coefficient-sequence)
  (accumulate (lambda (this-coeff higher-terms) (+ this-coeff (* x higher-terms)))
              0
              coefficient-sequence))
#+END_SRC

置換モデル
#+BEGIN_SRC scheme
(horner-eval 2 (list 1 3 0 5 0 1))
(+ 1 (* 2 (+ 3 (* 2 (+ 0 (* 2 (+ 5 (* 2 (+ 0 (* 2 (+ 1 (* 0 0))))))))))))
(+ 1 (* 2 (+ 3 (* 2 (+ 0 (* 2 (+ 5 (* 2 (+ 0 (* 2 (+ 1 0)))))))))))
(+ 1 (* 2 (+ 3 (* 2 (+ 0 (* 2 (+ 5 (* 2 (+ 0 (* 2 1))))))))))
(+ 1 (* 2 (+ 3 (* 2 (+ 0 (* 2 (+ 5 (* 2 (+ 0 2)))))))))
(+ 1 (* 2 (+ 3 (* 2 (+ 0 (* 2 (+ 5 (* 2 2))))))))
(+ 1 (* 2 (+ 3 (* 2 (+ 0 (* 2 (+ 5 4)))))))
(+ 1 (* 2 (+ 3 (* 2 (+ 0 (* 2 9))))))
(+ 1 (* 2 (+ 3 (* 2 (+ 0 18)))))
(+ 1 (* 2 (+ 3 (* 2 18))))
(+ 1 (* 2 (+ 3 36)))
(+ 1 (* 2 39))
(+ 1 78)
79
#+END_SRC

動作確認
#+BEGIN_SRC scheme
(horner-eval 2 (list 1 3 0 5 0 1)) ;; expected to 79
> 79
#+END_SRC

*** 練習問題 2.35

count-leavesを集積として再定義する。以下はそのひながた
#+BEGIN_SRC scheme
(define (count-leaves t)
  (accumulate <??> <??> (map <??> <??>)))
#+END_SRC

回答
#+BEGIN_SRC scheme
;; ボツ回答1. もっとシンプルに出来るはず
(define (count-leaves t)
  (accumulate + 0 (map (lambda (x) (cond ((null? x) '())
                                         ((not (pair? x)) (list 1))
                                         (else (append (car x) (cdr x)))))
                       t)))
;; 以下のようなエラーが出てしまう。# + は (1)と0の間では定義されていない。リストとスカラは+出来ないということ。
;;gosh> (count-leaves (list 1 2 3 4))
;;*** ERROR: operation + is not defined between (1) and 0


;; 回答2
;;; 補助手続き
(define (enumerate-tree tree)
  (cond ((null? tree) '())
        ((not (pair? tree)) (list tree))
        (else (append (enumerate-tree (car tree))
                      (enumerate-tree (cdr tree))))))

(define (count-leaves t)
  (accumulate + 0 (map (lambda (x) 1) (enumerate-tree t))))
#+END_SRC


動作確認
#+BEGIN_SRC scheme
(count-leaves (list 1 2 3 4)) ;; expected to 4
> 4
(count-leaves (list 1 2 (list 3 4 (list 5)) 6 (list 7 8))) ;; expected to 8
> 8
#+END_SRC

*** 練習問題 2.36

accumulate-nの雛形
#+BEGIN_SRC scheme
(define (accumulate-n op init seqs)
  (if (null? (car seqs))
      '()
      (cons (accumulate op init <??>)
            (accumulate-n op init <??>))))
#+END_SRC

回答
#+BEGIN_SRC scheme
(define (accumulate-n op init seqs)
  (if (null? (car seqs))
      '()
      (cons (accumulate op init (map (lambda (x) (car x)) seqs))
            (accumulate-n op init (map (lambda (x) (cdr x)) seqs)))))
#+END_SRC

動作確認
#+BEGIN_SRC scheme
(define s (list (list 1 2 3) (list 4 5 6) (list 7 8 9) (list 10 11 12)))
(accumulate-n + 0 s) ;; expected to (22 26 30)
> (22 26 30)
#+END_SRC

*** 練習問題 2.37

ベクトル・行列演算のテンプレート
#+BEGIN_SRC scheme
;; dot-product: 内積
(define (dot-product v w)
  (accumulate + 0 (map * v w)))

;; matrix-*-vector: 行列とベクトルの積
(define (matrix-*-vector m v)
  (map <??> m))

;; transpose: 転置行列
(define (transpose mat)
  (accumulate-n <??> <??> mat))

;; matrix-*-matrix: 行列同士の積
(define (matrix-*-matrix m n)
  (let ((cols (transpose n)))
    (map <??> m)))
#+END_SRC

回答
#+BEGIN_SRC scheme
;; matrix-*-vector: 行列とベクトルの積
(define (matrix-*-vector m v)
  (map (lambda (x) (dot-product x v)) m))

;; transpose: 転置行列
(define (transpose mat)
  (accumulate-n cons '() mat))

;; matrix-*-matrix: 行列同士の積
(define (matrix-*-matrix m n)
  (let ((cols (transpose n)))
    (map (lambda (x) (matrix-*-vector cols x)) m)))
#+END_SRC

動作確認
#+BEGIN_SRC scheme
;; 補助手続き
(define (accumulate op initial sequence)
  (if (null? sequence)
      initial
      (op (car sequence)
          (accumulate op initial (cdr sequence)))))

;; test data
(define v1 (list 1 2 3))
(define v2 (list 4 5 6))
(define v3 (list 7 8 9))
(define vx (list 2 3 4))
(define m1 (list v1 v2 v3))
(define m2 (list (list 1 2) (list 2 3) (list 3 4)))

;; test dot-product
(matrix-*-vector m1 vx) ;; expected to (20 47 74)
> (20 47 74)

;; test transpose
(transpose m1) ;; expected to ((1 4 7) (2 5 8) (3 6 9))
> ((1 4 7) (2 5 8) (3 6 9))
(transpose (list v1 v3)) ;; expected to ((1 7) (2 8) (3 9))
> ((1 7) (2 8) (3 9))
(transpose '()) ;; expected to ()
> 
(transpose v1) ;; expected to ((1) (2) (3))
;;*** ERROR: pair required, but got 1
;;Stack Trace:
;;_______________________________________
;;  0  (car x)
;;        at "(standard input)":16
;;  1  (map (lambda (x) (car x)) seqs)
;;        at "(standard input)":16
;;  2  (accumulate op init (map (lambda (x) (car x)) seqs))
;;        at "(standard input)":16
;;  3  (eval expr env)
;;        at "/usr/local/Cellar/gauche/0.9.9/share/gauche-0.97/0.9.9/lib/gauche/interactive.scm":269
;; ベクトルの転置はできない。エラーはaccumulate-nの元々ある部分のものなのでこれで良しとする。

;; test matrix-*-matrix
(matrix-*-matrix m1 m2) ;; expected to ((14 20) (32 47) (50 74))
> ((14 20) (32 47) (50 74))
#+END_SRC

*** 練習問題 2.38

fold-right (=accumulate) と fold-leftの定義
#+BEGIN_SRC scheme
;; fold-right
(define (fold-right op initial sequence)
  (if (null? sequence)
      initial
      (op (car sequence)
          (accumulate op initial (cdr sequence)))))

;; fold-left
(define (fold-left op initial sequence)
  (define (iter result rest)
    (if (null? rest)
        result
        (iter (op result (car rest))
              (cdr rest))))
  (iter initial sequence))
#+END_SRC

式の値
#+BEGIN_SRC scheme
(fold-right / 1 (list 1 2 3)) ;; expected to 3/2
> 3/2
(fold-left / 1 (list 1 2 3)) ;; expected to 1/6
> 1/6
(fold-right list '() (list 1 2 3)) ;; expected to (1 (2 (3 ())))
> (1 (2 (3 ())))
(fold-left list '() (list 1 2 3)) ;; expected to (((() 1) 2) 3()
> (((() 1) 2) 3)
#+END_SRC

- opが満たさなければならない性質
  - 可換である（交換則が成り立つ）こと
その検証
#+BEGIN_SRC scheme
(fold-right + 0 (list 1 2 3)) ;; expected to 6
> 6
(fold-left + 0 (list 1 2 3)) ;; expected to 6
> 6

(fold-right * 1 (list 1 2 3)) ;; expected to 6
> 6
(fold-left * 1 (list 1 2 3)) ;; expected to 6
> 6
#+END_SRC

*** 練習問題 2.39

reverseのテンプレート
#+BEGIN_SRC scheme
(define (reverse sequence)
  (fold-right (lambda (x y) <??>) nil sequence))

(define (reverse sequence)
  (fold-left (lambda (x y) <??>) nil sequence))
#+END_SRC

回答
#+BEGIN_SRC scheme
(define (reverse-r sequence) ;; 手続き名は敢えて変更
  (fold-right (lambda (x y) (append y (list x))) '() sequence))

(define (reverse-l sequence) ;; 手続き名は敢えて変更
  (fold-left (lambda (x y) (cons y x)) '() sequence))
#+END_SRC

動作確認
#+BEGIN_SRC scheme
(reverse-r (list 1 2 3 4)) ;; expected to (4 3 2 1)
> (4 3 2 1)

(reverse-l (list 1 2 3 4)) ;; expected to (4 3 2 1)
> (4 3 2 1)
#+END_SRC

 appendは可換ではない。

*** その他

- [[https://qiita.com/kaz-yos/items/d1ecd4bfe9989c290e99][qiita]] とかにfold-rignt, fold-leftに言及していた。
- fold-right/fold-leftに関する[[https://en.wikipedia.org/wiki/Fold_(higher-order_function)][wikipedia記事]]図が参考になる。

** マップのネスト

- 列というパラダイムを拡張（マップをネスト）して、普通はネストしたルー
  プによって表現されるような多くの計算に適用できる。
- 計算例: 正の整数nが与えられた時、1<=j<i<=nで、かつi+jが素数となるよう
  な異なる正の整数iとjのすべての順序つきペアを見つける
  - n以下の正の整数からなる大きい順に並んだ全てのペアの列を生成
  - フィルタにより合計が素数となるペアを選択
  - フィルタを通過したペア(i,j)に対し(i,j,i+j)という三つ組を作る
- ペアの列の生成方法
  - 全ての整数i<=nに対して整数j<iを列挙し、iとjすべてに対して(i,j)を生成する
    - (enumerate-interval 1 n)の列にマップを行う
    - 列のそれぞれのiに対し(enumerate-interval 1 (- i 1))という列にマップ
    - 後者の列のそれぞれのjに対して、(list i j)というペアを生成する
    - それぞれのiに対する列ができるので、それらをappendで集積する
#+BEGIN_SRC scheme
(accumulate append
            '() (map (lamnbda (i)
                       (map (lambda (j) (list i j))
                            (enumerate-interval 1 (- i 1))))
                     (enumerate-interval 1 n)))
#+END_SRC

理解のための動作確認
#+BEGIN_SRC scheme
;; 補助関数
(define (enumerate-interval low high)
  (if (> low high)
      '()
      (cons low (enumerate-interval (+ low 1) high))))

;; appendで集積しない場合、各i毎に列としてまとめられてしまっている
(define (f n)
  (map (lambda (i)
               (map (lambda (j) (list i j))
                    (enumerate-interval 1 (- i 1))))
       (enumerate-interval 1 n)))
(f 6)
> (() ((2 1)) ((3 1) (3 2)) ((4 1) (4 2) (4 3)) ((5 1) (5 2) (5 3) (5 4))
 ((6 1) (6 2) (6 3) (6 4) (6 5)))

;; appendで集積すると各iに対するペア列も展開されてフラットな列になる。だから "flat-map" ということか。
(define (g n)
  (accumulate append
            '()
            (map (lambda (i) (map (lambda (j) (list i j))
                                  (enumerate-interval 1 (- i 1))))
                 (enumerate-interval 1 n))))
(g 6)
> ((2 1) (3 1) (3 2) (4 1) (4 2) (4 3) (5 1) (5 2) (5 3) (5 4) (6 1) (6 2) (6 3)
 (6 4) (6 5))
#+END_SRC

マップと集積をappendによって組み合わせることはよくあることなので
*flatmap* という独立した手続きとして分離しておく。
#+BEGIN_SRC scheme
;; flatmap
(define (flatmap proc seq)
  (accumulate append '() (map proc seq)))
#+END_SRC

次にペアの列をフィルタして和が素数となるものを探す。この場合述語の引数はペアになる。
#+BEGIN_SRC scheme
;; 補助関数: prime? from 1.2.6
(define (prime? n)
  (define (smallest-divisor n) (find-divisor n 2))
  (define (find-divisor n test-divisor)
    (cond ((> (square test-divisor) n) n)
          ((divides? test-divisor n) test-divisor)
          (else (find-divisor n (+ test-divisor 1)))))
  (define (divides? a b) (= (remainder b a) 0))
  (= n (smallest-divisor n)))

(define (prime-sum? pair)
  (prime? (+ (car pair) (cadr pair)))) ;; (list x y) でyを取り出すときは cadr を使うのが自然ということか
#+END_SRC

最後にフィルタを通ったペアの列をマップして結果の列を生成する。
#+BEGIN_SRC scheme
(define (make-pair-sum pair)
  (list (car pair) (cadr pair) (+ (car pair) (cadr pair))))
#+END_SRC

これらを全て組み合わせる。
#+BEGIN_SRC scheme
(define (prime-sum-pairs n)
  (map make-pair-sum
       (filter prime-sum? (flatmap (lambda (i) (map (lambda (j) (list i j))
                                                    (enumerate-interval 1 (- i 1))))
                                   (enumerate-interval 1 n)))))

;; 動作確認
(prime-sum-pairs 6)
> ((2 1 3) (3 2 5) (4 1 5) (4 3 7) (5 2 7) (6 1 7) (6 5 11))
#+END_SRC


マップのネストは区間の列挙以外にも役に立つ。例として、ある集合Sに対し
てその順列を生成することを考える。例えば {1,2,3}の順列は、
                             #+BEGIN_SRC 
{1,2,3}, {1,3,2}, {2,1,3}, {2,3,1}, {3,1,2}, {3,2,1}
#+END_SRC
となる。

#+BEGIN_SRC scheme
(define (permutations s)
  (if (null? s)
      (list '())
      (flatmap (lambda (x) (map (lambda (p) (cons x p))
                                (permutations (remove x s))))
               s)))

(define (remove item sequence)
  (filter (lambda (x) (not (= x item)))
         sequence))

;; 動作確認
(permutations (list 1 2 3))
> ((1 2 3) (1 3 2) (2 1 3) (2 3 1) (3 1 2) (3 2 1))
#+END_SRC

** 練習問題
*** 練習問題 2.40 

回答
#+BEGIN_SRC scheme
;; unique-pairs
(define (unique-pairs n)
  (flatmap (lambda (i) (map (lambda (j) (list i j))
                            (enumerate-interval 1 (- i 1))))
           (enumerate-interval 1 n)))

;; prime-sum-pairs w/unique-pairs
(define (prime-sum-pairs n)
  (map make-pair-sum
       (filter prime-sum? (unique-pairs n))))
#+END_SRC

動作確認
#+BEGIN_SRC scheme
;; unique-pairsのテスト
(unique-pairs 6)
> ((2 1) (3 1) (3 2) (4 1) (4 2) (4 3) (5 1) (5 2) (5 3) (5 4) (6 1) (6 2) (6 3)
 (6 4) (6 5))

;; unique-pairsを使ったprime-sum-pairsのテスト
(prime-sum-pairs 6)
((2 1 3) (3 2 5) (4 1 5) (4 3 7) (5 2 7) (6 1 7) (6 5 11))
#+END_SRC

*** 練習問題 2.41 

練習
#+BEGIN_SRC scheme
(define (f n)
  (flatmap (lambda (i) (map (lambda (j) (map (lambda (k) (list i j k))
                                             (enumerate-interval 1 (- i 2))))
                            (enumerate-interval 1 (- i 1))))
           (enumerate-interval 1 n)))

(f 6)
> (() ((3 1 1)) ((3 2 1)) ((4 1 1) (4 1 2)) ((4 2 1) (4 2 2)) ((4 3 1) (4 3 2))
 ((5 1 1) (5 1 2) (5 1 3)) ((5 2 1) (5 2 2) (5 2 3)) ((5 3 1) (5 3 2) (5 3 3))
 ((5 4 1) (5 4 2) (5 4 3)) ((6 1 1) (6 1 2) (6 1 3) (6 1 4))
 ((6 2 1) (6 2 2) (6 2 3) (6 2 4)) ((6 3 1) (6 3 2) (6 3 3) (6 3 4))
 ((6 4 1) (6 4 2) (6 4 3) (6 4 4)) ((6 5 1) (6 5 2) (6 5 3) (6 5 4)))
;; 列の列になってしまっている。大小順でもない。重複する数値の組が存在する

;; flatmapをネストしてみる
(define (f n)
  (flatmap (lambda (i) (flatmap (lambda (j) (map (lambda (k) (list i j k))
                                                 (enumerate-interval 1 (- i 2))))
                                (enumerate-interval 1 (- i 1))))
           (enumerate-interval 1 n)))

(f 6)
> ((3 1 1) (3 2 1) (4 1 1) (4 1 2) (4 2 1) (4 2 2) (4 3 1) (4 3 2) (5 1 1)
 (5 1 2) (5 1 3) (5 2 1) (5 2 2) (5 2 3) (5 3 1) (5 3 2) (5 3 3) (5 4 1)
 (5 4 2) (5 4 3) (6 1 1) (6 1 2) (6 1 3) (6 1 4) (6 2 1) (6 2 2) (6 2 3)
 (6 2 4) (6 3 1) (6 3 2) (6 3 3) (6 3 4) (6 4 1) (6 4 2) (6 4 3) (6 4 4)
 (6 5 1) (6 5 2) (6 5 3) (6 5 4))
;; 列の列は直せた。重複する数値を持つタプルの除去をどうすべきか

;; 合計がsかつ重複する数値を持っていないタプルを選択するフィルタを作る
(define (filter-tuple s tup)
  (define (sum-tuple t) (+ (car t) (cadr t) (caddr t)))
  (define (unique-tuple? t) (not (or (= (car t) (cadr t))
                                   (= (cadr t) (caddr t))
                                   (= (car t) (caddr t)))))
  (and (= s (sum-tuple tup)) (unique-tuple? tup)))

(filter-tuple 6 (list 1 2 3)) ;; expected to #t
> #t
(filter-tuple 5 (list 1 2 3)) ;; expected to #f
> #f
#+END_SRC

回答
#+BEGIN_SRC scheme
;; 補助関数
(define (enumerate-interval low high)
  (if (> low high)
      '()
      (cons low (enumerate-interval (+ low 1) high))))
(define (accumulate op init seq)
  (if (null? seq)
      init
      (op (car seq) (accumulate op init (cdr seq)))))
(define (flatmap proc seq)
  (accumulate append '() (map proc seq)))
(define (unique-pairs n)
  (flatmap (lambda (i) (map (lambda (j) (list i j))
                            (enumerate-interval 1 (- i 1))))
           (enumerate-interval 1 n)))

;;---- ここからが実際の回答 ----;;
;; make-unique-tuples
(define (unique-tuple n)
  (flatmap (lambda (i)
             (map (lambda (j) (append (list i) j))
                  (unique-pairs (- i 1))))
           (enumerate-interval 1 n)))

;; filter
(define (equals-to-s? s tup)
  (= s (+ (car tup) (cadr tup) (caddr tup))))

;; integration
(define (s-equals-to-sum-of-tuple s n)
  (filter (lambda (t) (equals-to-s? s t))
          (unique-tuple n)))
#+END_SRC

動作確認
#+BEGIN_SRC scheme
(s-equals-to-sum-of-tuple 10 6) ;; expected to ((5 3 2) (5 4 1) (6 3 1))
> ((5 3 2) (5 4 1) (6 3 1))
#+END_SRC

- *(コメント)*
  - 上手く動いているが、unique-tupleでのflatmapが正直まだ完全に理解で
    きていない。こんな感じかなとコードを書いて動かしてみたら上手く動い
    たという状態なのでちゃんと動作を理解すること
  - flatmapは（列の各項目にprocを適用しつつ）列の列を単一の列に展開する
    手続きという理解でよいか？
    - 列の列の列の場合は列の列になる

*** 練習問題 2.42 

queensの雛形
#+BEGIN_SRC scheme
;;
;; variables
;;   empty-board    位置の空集合
;;   positions      k列までの位置集合(列の列の列か。列の列で１つの盤上の位置パターンを表し、さらにそれらのパターンの列を形成する)
(define (queens board-size)
  (define (queen-cols k)
    (if (= k 0)
        (list empty-board) ;; 要実装
        (filter
          (lambda (positions) (safe? k positions)) ;; 要実装
          (flatmap
            (lambda (rest-of-queens) ;; k-1列にk-1個のクイーンを置くパターンの一つ
              (map (lambda (new-row) ;; k列目のクイーンを置く候補となる行
                     (adjoin-position ;; 要実装
                     new-row k rest-of-queens))
                   (enumerate-interval 1 board-size)))
            (queen-cols (- k 1))))))
   (queen-cols board-size))

;; 実装要諦手続き
(define (adjoin-position new-row k rest-of-queens) <??>) ;; 位置集合に新しい行・列の位置を追加する
(define empty-board <??>)                                ;; 位置の空集合（初期ボードを表現）
(define (safe? k positions) <??>)                        ;; k列目のクイーンが他のクイーンの利き筋にはいっていないかをテストする

#+END_SRC

回答
#+BEGIN_SRC scheme
(define (adjoin-position new-row k rest)
  (if (or (null? rest) (null? (car rest))))
      (list new-row)
      ())
#+END_SRC

練習
#+BEGIN_SRC scheme
(define empty-board (map (lambda (i) (list ())) (enumerate-interval 1)))
(define (f size n)
  ())
#+END_SRC

振り返り
#+BEGIN_SRC scheme
(define (flatmap proc seq)
  (accumulate append '() (map proc seq)))

(define (map p sequence)
  (accumulate (lambda (x y) (cons (p x) y)) '() sequence))

(define (accumulate op init seq)
  (if (null? seq)
      init
      (op (car seq) (accumulate op init (cdr seq)))))

(map (lambda (x) (+ x 1)) (list 1 2 3))
(accumulate (lambda (x y) (cons ((lambda (z) (+ z 1)) x) y)) () (1 2 3)) ((lambda (x y) (cons ((lambda (z) (+ z 1)) x) y)) 1 (accumulate (lambda (x y) (cons ((lambda (z) (+ z 1)) x) y)) () (2 3)))
((lambda (x y) (cons ((lambda (z) (+ z 1)) x) y)) 1 ((lambda (x y) (cons ((lambda (z) (+ z 1)) x) y)) 2 (accumulate (lambda (x y) (cons ((lambda (z) (+ z 1)) x) y)) () (3))))
((lambda (x y) (cons ((lambda (z) (+ z 1)) x) y)) 1 ((lambda (x y) (cons ((lambda (z) (+ z 1)) x) y)) 2 ((lambda (x y) (cons ((lambda (z) (+ z 1)) x) y)) 3 (accumulate (lambda (x y) (cons ((lambda (z) (+ z 1)) x) y)) () ()))))
((lambda (x y) (cons ((lambda (z) (+ z 1)) x) y)) 1 ((lambda (x y) (cons ((lambda (z) (+ z 1)) x) y)) 2 ((lambda (x y) (cons ((lambda (z) (+ z 1)) x) y)) 3 '()))) ((lambda (x y) (cons ((lambda (z) (+ z 1)) x) y)) 1 ((lambda (x y) (cons ((lambda (z) (+ z 1)) x) y)) 2 (cons 4 '())))
((lambda (x y) (cons ((lambda (z) (+ z 1)) x) y)) 1 (cons ((lambda (z) (+ z 1)) 2) (cons 4 '())))
((lambda (x y) (cons ((lambda (z) (+ z 1)) x) y)) 1 (cons 3 (cons 4 '())))
(cons ((lambda (z) (+ z 1)) 1) (cons 3 (cons 4 '())))
(cons 2 (cons 3 (cons 4 '())))
(2 3 4)

;; 各種手続きの定義
(define (flatmap proc seq)
  (accumulate append '() (map proc seq)))

(define (accumulate op init seq)
  (if (null? seq)
      init
      (op (car seq) (accumulate op init (cdr seq)))))

;; mapはaccumulate版とよりプリミティブなバージョンがある。
(define (map proc seq)
  (if (null? seq)
      '()
      (cons (proc (car seq)) (map proc (cdr seq)))))
(define (map p sequence)
  (accumulate (lambda (x y) (cons (p x) y)) '() sequence))

(define (enumerate-interval low high)
  (if (> low high)
      '()
      (cons low (enumerate-interval (+ low 1) high))))
#+END_SRC

検討
- mapはcdrダウンとconsアップによりprocを列のcarに適用した結果の列を返す
- map自体に列の列を作る機能はない。あくまでもmapに渡されるprocとseqに
  より列の列はつくられるはず
board-size=4としたときの動作を考える
- k=0のとき
  - (queen-cols 0)の評価結果は empty-board
- k=1のとき
  - flatmapに適用される列はempty-board
  - adjoin-positionのmapは
    - (map (lambda (new-row) (adjoin-position new-row 2 empty)) (1 2 3 4))
      - (cons (adjoin-position 1 1 empty)
          (cons (adjoin-position 2 1 empty)
            (cons (adjoin-position 3 1 empty)
              (cons (adjoin-position 4 1 empty))))
      - (((1) (2) (3) (4))) ;; になるべき
  - flatmapの結果は
    - ((1) (2) (3) (4)) ;; になるべき
  - filterの結果は（）k=0のときとは利かないので全パターンを通す
    - ((1) (2) (3) (4))
- k=2
  - flatmapに適用される列は'((1) (2) (3) (4))
  - adjoin-positionのmapは
    - (map (lambda (new-row) (adjoin-position new-row 2 (1))) (1 2 3 4))
      - (cons (adjoin-position 1 2 (1))
          (cons (adjoin-position 2 2 (1)))
            (cons (adjoin-position 3 2 (1)))
              (cons (adjoin-position 4 2 (1))) '())
      - ((1 1) (1 2) (1 3) (1 4))
    - (map (lambda (new-row) (adjoin-position new-row 2 (2))) (1 2 3 4))
      - (cons (adjoin-position 1 2 (2))
          (cons (adjoin-position 2 2 (2)))
            (cons (adjoin-position 3 2 (2)))
              (cons (adjoin-position 4 2 (2))) '())
      - ((2 1) (2 2) (2 3) (2 4))
    - (map (lambda (new-row) (adjoin-position new-row 2 (3))) (1 2 3 4))
      - (cons (adjoin-position 1 2 (3))
          (cons (adjoin-position 2 2 (3)))
            (cons (adjoin-position 3 2 (3)))
              (cons (adjoin-position 4 2 (3))) '())
      - ((3 1) (3 2) (3 3) (3 4))
    - (map (lambda (new-row) (adjoin-position new-row 2 (4))) (1 2 3 4))
      - (cons (adjoin-position 1 2 (4))
          (cons (adjoin-position 2 2 (4)))
            (cons (adjoin-position 3 2 (4)))
              (cons (adjoin-position 4 2 (4))) '())
      - ((4 1) (4 2) (4 3) (4 4))
  - flatmapの結果は
    - ((1 1) (1 2) (1 3) (1 4) (2 1) (2 2) (2 3) (2 4) (3 1) (3 2) (3 3) (3 4) (4 1) (4 2) (4 3) (4 4))
  - になるはず。
- つまりqueen-colsはfilterを無視した場合、1からboard-sizeまでの数値の
  一意な組み合わせの列挙を行う


#+BEGIN_SRC scheme
(define (f x)
   (flatmap (lambda (rest) (map (lambda (n) (list n)) (enumerate-interval 1 x))) '(())))
#+END_SRC

*** 練習問題 2.43
TBD

* 2.2.4 例: 図形言語

- この節では図形を描く簡単な言語を紹介することで抽象と閉包の持つ力を示
  し、公開手続きの本質的な部分を利用する
- この言語は要素をずらしたり拡大縮小したりしたものによって構成されるパ
  ターンについての実験がやりやすいように設計されている
- この言語も閉包性をみたし、どんな複雑なパターンでも簡単に構築できる

#+BEGIN_SRC 
（復習）閉包性 (from 2.2 階層データと閉包性より)

データオブジェクトを組み合わせる”操作”は、その演算による組み合わせの結果自身が同じ演算によって組み合わせることが出来るなら「閉包性」を満たすという
#+END_SRC


** 図形言語

言語を記述する際のポイント
- 言語の基本要素
- 組み合わせ方法
- 抽象化方法

この図形言語のエレガントさの一つは *ペインタ(painter)* という一種類の要素しか持たせていないというもの

*ペインタ*: 指定された平行四辺形型の枠にフィットするように画像をずらしたり拡大縮小したりしたものを描画する

（基本）ペインタの例
 - wave
 - rogers

*jakldによる図形言語環境準備*
#+BEGIN_SRC scheme
;; 描画ウィンドウの表示
(start-picture)
;; Standard frame
(define frm1 (make-frame (make-vect 0.0 0.0)
                         (make-vect 1.0 0.0)
                         (make-vect 0.0 1.0)))
;; 描画手続き
(define (show painter . frame)
  (clear-picture)
  (painter (if (null? frame) frm1 (car frame))))
;; ロジャース
(define rogers (image->painter "./rogers.gif"))
;; 線画
(define wave
  (let ((p01 (make-vect 0.40 1.00))
        (p02 (make-vect 0.60 1.00))
        (p03 (make-vect 0.00 0.80))
        (p04 (make-vect 0.35 0.80))
        (p05 (make-vect 0.65 0.80))
        (p06 (make-vect 0.00 0.60))
        (p07 (make-vect 0.30 0.60))
        (p08 (make-vect 0.40 0.60))
        (p09 (make-vect 0.60 0.60))
        (p10 (make-vect 0.70 0.60))
        (p11 (make-vect 0.20 0.55))
        (p12 (make-vect 0.30 0.55))
        (p13 (make-vect 0.35 0.50))
        (p14 (make-vect 0.65 0.50))
        (p15 (make-vect 0.20 0.45))
        (p16 (make-vect 1.00 0.40))
        (p17 (make-vect 0.50 0.20))
        (p18 (make-vect 1.00 0.20))
        (p19 (make-vect 0.25 0.00))
        (p20 (make-vect 0.40 0.00))
        (p21 (make-vect 0.60 0.00))
        (p22 (make-vect 0.75 0.00)))
    (segments->painter
      (list (make-segment p01 p04)
            (make-segment p04 p08)
            (make-segment p08 p07)
            (make-segment p07 p11)
            (make-segment p11 p03)
            (make-segment p06 p15)
            (make-segment p15 p12)
            (make-segment p12 p13)
            (make-segment p13 p19)
            (make-segment p20 p17)
            (make-segment p17 p21)
            (make-segment p22 p14)
            (make-segment p14 p18)
            (make-segment p16 p10)
            (make-segment p10 p09)
            (make-segment p09 p05)
            (make-segment p05 p02)))))
#+END_SRC

画像を結合するには、与えられたペインタから新しいペインタを構築するいろいろな演算を使う
- ~beside~: 2つのペインタを引数にとり、枠の左半分に1つ目のペインタ、右半分に2つ目のペインタの画像を描く新しい複合ペインタを作る
- ~below~: 2つのペインタを引数にとり、2つ目のペインタの画像の下に1つ目のペインタの画像を描く複合ペインタを作る
- ~flip-vert~: 1つのペインタを引数にとり、その画像を上下逆に描くペインタを作る
- ~flip-horiz~: 1つのペインタを引数にとり、その画像左右逆に描くペインタを作る

例) waveから始めて、二段階を経て構築したwave4の描く画像（図2.12）
#+BEGIN_SRC scheme
(define wave2 (beside wave (flip-vert wave)))
(define wave4 (below wave2 wave2))

;; 動作確認
(show wave2)
(show wave4)
#+END_SRC
[[TBD/実行結果]]

ペインタはこの言語の結合手段について閉じているので、より複雑なペインタを作るのに、それを要素して使うことが可能
- ペインタ: 図形言語のデータオブジェクト
- beside, flip-vert, etc.: データオブジェクトを操作する演算
- ペインタを演算した結果もペインタという閉包性を持つ

データが結合手段について閉じている -> 少しの演算によって複雑な構造を作る能力を実現するうえで決定的に重要

よくある結合パターンを抽象化する。
- ペインタ演算をSchemeの手続きとして実装することで、図形言語のための特別な抽象化メカニズムは不要となる

例えば、wave4に出てくるパターンは次のように抽象化できる
#+BEGIN_SRC scheme
(define (flipped-pairs painter)
  (let ((painter2 (beside painter (flip-vert painter))))
    (below painter2 painter2)))

(define wave4 (flipped-pairs wave))

;; 動作確認
(show wave4)
#+END_SRC
[[TBD/実行結果]]


再帰演算の定義可能。（図2.13, 2.14のような、右方向や右上方向に枝分かれしていくペインタ）
#+BEGIN_SRC scheme
;; 右方向への枝分かれ
(define (right-split painter n)
  (if (= n 0)
      painter
      (let ((smaller (right-split painter (- n 1))))
        (beside painter (below smaller smaller)))))

;; 動作確認
(show (right-split wave 4))
(show (right-split rogers 4))

;; 右上方向への枝分かれ
(define (corner-split painter n)
  (if (= n 0)
      painter
      (let ((up (up-split painter (- n 1)))
            (right (right-split painter (- n 1))))
        (let ((top-left (beside up up))
              (bottom-right (below right right))
              (corner (corner-split painter (- n 1))))
          (beside (below painter top-left)
                  (below bottom-right corner))))))

;; 動作確認
(show (corner-split wave 4))
(show (corner-split rogers 4))
#+END_SRC
[[TBD/実行結果]]

*(コメント) PDFファイル版SICPの図2.14はn=4じゃなくてn=5の間違い。本のSICPはちゃんとn=4の場合の描画になっている。*

図2.9はsquare-limit手続きの出力結果
#+BEGIN_SRC scheme
(define (square-limit painter n)
  (let ((quarter (corner-split painter n)))
    (let ((half (beside (flip-horiz quarter) quarter)))
      (below (flip-vert half) half))))

;; 動作確認
(show (square-limit wave 4))
(show (square-limit rogers 4))
#+END_SRC
[[TBD/実行結果]]

** 練習問題
*** 練習問題 2.44 up-split手続き

回答
#+BEGIN_SRC scheme
(define (up-split painter n)
  (if (= n 0)
      painter
      (let ((smaller (up-split painter (- n 1))))
        (below painter (beside smaller smaller)))))
#+END_SRC

動作確認
#+BEGIN_SRC scheme
(show (up-split wave 4))
(show (up-split rogers 4))
#+END_SRC
TBD

** 高階関数

ペインタを組み合わせるパターンの抽象化だけでなく、より高いレベルでペインタ演算を組み合わせるパターンの抽象化もできる
- ペインタ演算を引数としてとり、新しいペインタ演算を作るような手続き、を書くことが出来る

例: flipped-pairsとsquare-limitのパターンの抽象化。
- 以下の手続は、4つの1引数ペインタ演算を引数として取り、ある与えられたペインタをこれらの4つの演算によって変形したものを正方形に配置するペインタ演算を作る
#+BEGIN_SRC scheme
(define (square-of-four tl tr bl br)
  (lambda (painter)
    (let ((top (beside (tl painter) (tr painter)))
          (bottom (beside (bl painter) (br painter))))
      (below bottom top))))

;; flipped-pairs by square-of-four
(define (flipped-pairs painter)
  (let ((combine4 (square-of-four identity flip-vert
                                  identity flip-vert)))
    (combine4 painter)))
;; 上と等価な書き方(脚注24)より
(define flipped-pairs
  (square-of-four identity flip-vert identyty flip-vert))
;; 実行するときは (flipped-pairs painter) と呼べば良い

;; square-limit by sqaure-of-four
(define (square-limit painter n)
  (let ((combine4 (square-of-four flip-horiz identity rotate180 flip-vert)))
    (combine4 (corner-split painter n))))
#+END_SRC

*TBD 動作確認*

** 練習問題
*** 練習問題 2.45

right-splitとup-splitの定義
#+BEGIN_SRC scheme
(define right-split (split beside below))
(define up-split (split below beside))
#+END_SRC

回答: splitの定義
#+BEGIN_SRC scheme
(define (split op1 op2)
  (define (iter painter n)
    (if (= n 0)
        painter
        (let ((smaller (iter painter (- n 1))))
          (op1 painter (op2 smaller smaller)))))
  (lambda (x y) (iter x y)))
#+END_SRC

*TBD 動作確認*
#+BEGIN_SRC scheme
;; right-split
TBD

;; up-split
TBD
#+END_SRC

** 枠

*枠* は三つのベクトルとして記述できる
- 原点ベクトル: 平面上の絶対原点からの枠の原点の相対位置を指定する
- 2つの辺ベクトル: 枠の原点を起点として、枠の2つの角の相対位置を指定する
  - 2つの辺が垂直なら枠は長方形になる

枠のコンストラクタとセレクタ
- ~make-frame~: 3つのベクトルを引数にとり枠を作るコンストラクタ
- ~origin-frame~: セレクタ
- ~edge1-frame~: セレクタ
- ~edge2-frame~: セレクタ

画像は単位正方形内の座標（0 <= x,y <= 1）を使って記述する

それぞれの枠には *枠座標マップ (frame coordinate map)* というものを関連付け、画像が枠に合うようにずらしたり拡大縮小したりするのに使う
- マップはベクトル v=(x,y) を ベクトルの和にマップすることによって単位正方形を枠内に変換する。
#+BEGIN_SRC 
Origin(Frame) + x * Edge1(Frame) + y * Edge2(Frame)
#+END_SRC

例えば、 (0,0)は枠の原点に、(1,1)は原点と対角線上にある頂点に、(0.5,0.5)は枠の中心にマップされる

枠座標マップは次の手続きによって作ることができる
#+BEGIN_SRC scheme
(define (frame-coord-map frame)
  (lambda (v)
    (add-vect
      (origin-frame frame)
      (add-vect (scale-vect (xcor-vect v) (edge1-frame frame))
                (scale-vect (ycor-vect v) (edge2-frame frame))))))
#+END_SRC

frame-coord-mapをある枠に適用すると、「ベクトルが与えられるとベクトルを返す」 *手続き* を返す。
- 引数ベクトルが単位正方形内にあれば、返り値のベクトルは枠内のものになる
#+BEGIN_SRC scheme
((frame-coord-map a-frame) (make-vect 0 0))
;; 上記は以下と同じベクトルを返す
(origin-frame a-frame)
#+END_SRC

** 練習問題
*** 練習問題 2.46 ベクトルに対するデータ抽象化

回答
#+BEGIN_SRC scheme
;; Vector's constructor and selectors
(define (make-vect x y) (cons x y))
(define (xcor-vect v) (car v))
(define (ycor-vect v) (cdr v))

;; add-vect: (x1, y1) + (x2, y2) = (x1 + x2, y1 + y2)
(define (add-vect v1 v2)
  (make-vect (+ (xcor-vect v1) (xcor-vect v2))
             (+ (ycor-vect v1) (ycor-vect v2))))

;; sub-vect: (x1, y1) - (x2, y2) = (x1 - x2, y1 - y2)
(define (sub-vect v1 v2)
  (make-vect (- (xcor-vect v1) (xcor-vect v2))
             (- (ycor-vect v1) (ycor-vect v2))))

;; scale-vect: s * (x, y) = (sx, sy)
(define (scale-vect s v)
  (make-vect (* s (xcor-vect v))
             (* s (ycor-vect v))))
#+END_SRC

動作確認
#+BEGIN_SRC scheme
;; add-vect test
TBD
;; sub-vect test
TBD
;; scale-vect test
TBD
#+END_SRC

*** 練習問題 2.47 枠の実装

二種類の枠のコンストラクタ
#+BEGIN_SRC scheme
;; by list
(define (make-frame origin edge1 edge2)
  (list origin edge1 edge2))
;; by cons
(define (make-frame origin edge1 edge2)
  (cons origin (cons edge1 edge2)))
#+END_SRC

回答: それぞれのコンストラクタに対するセレクタ
#+BEGIN_SRC scheme
;; for list
(define (origin-frame f) (car f))
(define (edge1-frame f) (cadr f))
(define (edge2-frame f) (caddr f))

;; for cons
(define (origin-frame f) (car f))
(define (edge1-frame f) (cadr f))
(define (edge2-frame f) (cddr f))
#+END_SRC

動作確認
TBD

** ペインタ

*ペインタ*: 枠を引数にとり、ある特定の画像をずらしたり拡大縮小したりして枠にフィットするように描画する手続き
- つまり、pがペインタでfがフレームであれば、(p f) でfの中にpの画像を生成する

基本ペインタがどのように実装されるかとう具体的なところはグラフィックシステムの特性と描画する画像のタイプに依存する。
例えば2つの指定された点の間に線を引く ~draw-line~ という手続きを持っているとすると、waveペインタのような線画のペインタは次のような線分のリストから作ることができる
#+BEGIN_SRC scheme
(define (segments->painter segment-list)
  (lambda (frame)
    (for-each
      (lambda (segment)
        (draw-line
          ((frame-coord-map frame)
           (start-segment segment))
          ((frame-coord-map frame)
           (end-segment segment))))
      segment-list)))
#+END_SRC

線分は単位正方形に対する座標を使って与えられる。
リスト中のそれぞれの線分に対し、ペインタは線分の両端点を枠座標マップを使って変換し、変換した点の間に線を引く

ペインタを手続きとして表現することは図形言語の中に強力な抽象化の壁を作る
- 様々なグラフィック機能に基づいて色々な基本ペインタを作り、組み合わせことが可能
- 枠を引数としてとり、その枠に合わせて何かを描くものであれば、どんな手続でもペインタとして使える
  - waveペインタ: 線画
  - rogersペインタ（注釈28参照）: 画像
  - 等

** 練習問題
*** 練習問題 2.48 線分の定義

回答
#+BEGIN_SRC scheme
(define (make-segment start end)
  (cons start end))
(define (start-segment segment) (car segment))
(define (end-segment segment) (cdr segment))
#+END_SRC

動作確認
#+BEGIN_SRC scheme
;; TBD
#+END_SRC

*** 練習問題 2.49

回答
#+BEGIN_SRC scheme
;; a. 枠の輪郭
;; (painter frame) という書き方になっていないので不十分
(define (outline->painter frame)
  (let ((v0 (make-vect 0 0))
        (v1 (edge1-frame frame))
        (v2 (edge2-frame frame)))
    (let ((v3 (add-vect v2 v1)))
      (segments->painter 
        (list (make-segment v0 v1)
              (make-segment v1 v3)
              (make-segment v3 v2)
              (make-segment v2 v0))))))

;; b. 枠の対角線
(define (diagonal->painter frame)
  (let ((v0 (make-vect 0 0))
        (v1 (edge1-frame frame))
        (v2 (edge2-frame frame)))
    (let ((v3 (add-vect v2 v1)))
      (segments->painter 
        (list (make-segment v0 v3)
              (make-segment v1 v2))))))

;; c. 枠の中点の菱形
(define (rhombus->painter frame)
  (let ((v0 (make-vect 0 0))
        (v1 (edge1-frame frame))
        (v2 (edge2-frame frame)))
    (let ((v3 (add-vect v2 v1)))
      (let ((v01 (scale-vect 0.5 (add-vect v0 v1)))
            (v13 (scale-vect 0.5 (add-vect v1 v3)))
            (v32 (scale-vect 0.5 (add-vect v3 v2)))
            (v20 (scale-vect 0.5 (add-vect v2 v0))))
        (segments->painter 
          (list (make-segment v01 v13)
                (make-segment v13 v32)
                (make-segment v32 v20)
                (make-segment v20 v01)))))))

;; d. wave
(TBD)
#+END_SRC

動作確認
#+BEGIN_SRC scheme
;; basic frame
(define f1 (make-frame (make-vect 0.1 0.1)
                       (make-vect 0.9 0.0)
                       (make-vect 0.0 0.9)))

;; a. outline->painter
(show (outline->painter f1) f1)

;; b. diagonal->painter
(show (diagonal->painter f1) f1)

;; c. rhombus->painter
(show (rhombus->painter f1) f1)
#+END_SRC
