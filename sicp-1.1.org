* 1 手続きを用いた抽象化の構築

- 計算プロセス(computational process)
  - 抽象的な存在
  - プロセスはデータ(data)と呼ばれる別の抽象物を操作する
  - プロセスの進化はプログラム(program)と呼ばれる規則のパターンによっ
    て指揮されている
- プログラムを作るのはプロセスを指揮するため
- 計算プロセスは精霊のようなもので、見たり触れたりできない
  - 物質によって作られていない
- Lisp
  - 1950年代の後半に再帰方程式についての推論を定式化するものとして発明
    された
  - アトム、リストという新しいデータオブジェクトを導入
- 何故Lisp(scheme)をプログラミングの考察のための枠組みとして使うのか？
  - プロセスのLispによる記述がそれ自身Lispのデータとして表され操作でき
    るから
    - 手続きをデータとして操作できる
  - これが重要なのは、"受動的な"データと"能動的"なプロセスという伝統的
    な区別を曖昧にする能力を使った強力なプログラム設計のテクニックが存
    在するから
- （引田感想）
  - この本ではこの、手続をデータとして操作することでプログラミングにお
    ける様々な興味深いテクニックについて考察していくのだろうか

** 1.1 プログラミングの要素

- 強力なプログラミング言語が持つ3つのメカニズム
  - 基本式
    - 言語に関わる最も単純な実体を表す
  - 組み合わせ方法
    - 複合要素をより単純なものから構築する方法
  - 抽象化方法
    - 複合要素に名前をつけ、単体として扱うための方法
- プログラミングで扱うもの
  - データ
    - 操作したい対象物
  - 手続き
    - データを操作するための規則を記述したもの

*** 1.1.1 式

Schemeでは、式(expression)を入力するとインタプリタはその式の評価
(evaluation)の結果を表示する。

数値は基本的な式の一つ

数値と基本的な手続きを表す式（+, *等）と組み合わせることで複合式を作り、
数値に対し手続きを適用することを表す。

#+begin_src sheme
(+ 137 349)
#+end_src

これらは組み合わせ(combination)と呼ばれる

- combination
  - 括弧の中の式のリスト（上記例では +, 137, 349）を区切ることにより作
    られ、手続きの適用を意味する

- 演算子
  - リストの左端の要素
- 被演算子
  - リストの演算子以外の要素

組み合わせの値は、
- 演算子によって指定された手続きを
- 被演算子の値である引数に適用
することによって得られる

- 前置記法(prefix notation)の利点
  - 曖昧さなく任意の数の引数に対応可能
  - 組み合わせをネストできる
    #+begin_src sheme
    (+ (* 3 5) (-10 6))
    #+end_src
    -> 19
- pretty-print
  - 被演算子が垂直に揃うように書くフォーマット
- （インタプリタの）REPL (read-eval-print-loop)モード
  - 式を端末から読み、式を評価し、結果を表示する

*** 1.1.2 命名と環境

- コンピュータ上のオブジェクトを指すために名前を利用する手段を提供する
  ことはプログラミング言語の重要な特徴の一つ
  - 値(value)がそのオブジェクトである変数(variable)を名前によって特定
    する
- Schemeではdefineによって対象に名前をつける

#+begin_src scheme
(define size 2)
#+end_src
defineはsizeという名前と2という値を関連付ける。

- インタプリタは段階的なプログラムの構築に特に便利
  - 名前とオブジェクトの関連付けを一連の対話を通して少しずつ作っていく
    ことが出来る。
- 環境(environment) or グローバル環境(global environment)
  - 名前とオブジェクトのペアを記録しておくためのメモリ

*** 1.1.3 組み合わせの評価

- この章の目的（の一つ）
  - 手続き的に考えるうえでの問題点を分解すること
- 組み合わせを評価するために行うこと
  1. 組み合わせの部分式を評価する
  2. 部分式の左端(つまり演算子)の値となっている手続きを、引数（被演算
     子）、つまり部分式の残りの値に適用する
- 評価規則は本質的に再帰的（recursive）
  - 組み合わせに対する手続きを評価するには組み合わせのそれぞれの要素に
    対する評価手続きを先にやらないといけないため
- 例
  #+begin_src scheme
  (* (+ 2 (* 4 6)
     (+ 3 5 7))
  #+end_src
  
この式を評価するには４つの異なる組み合わせに対して評価規則を適用する
必要がある。

- + 3 5 7
- * 4 6
- + 2 (* 4 6)
- * (+ 2 (* 4 6)) (+ 3 5 7)

この手続は組み合わせを木の形で表すことが出来る（図1.1）

- 木の集積（tree accumulation）
  - 値を上に向かって伝える評価規則

- 基本的な式（数値や組み込み演算子等）の評価規則
  - 数字の値はそれが示す値
  - 組み込み演算子の値は機械語の列で、それに対応する操作を実行する
  - その他の名前の値は、現在の環境でその名前に関連付けられたオブジェクト

- 式に出てくる記号の意味を決める上で環境の果たす役割はここでのキーポイント
- 特殊形式（special form）
  - 一般的評価規則に対する例外（define等）
  - それぞれの特殊形式は独自の評価規則を持つ
- それらの色々な種類の式はプログラミング言語の構文を構成する

- Lispは単純な構文を持つ
  - 一つの単純な一般規則と少数の特殊規則からなる

*** 1.1.4 複合手続き

- 強力なプログラミング言語が持っている要素
  - 数値は基本データで、算術演算は基本手続き
  - 組み合わせをネストすることで、演算を組み合わせることができる
  - 定義は名前と値を関連付け、抽象化のためにある程度役に立つ

- 手続きの定義(procedure definition)
  - 複合演算に名前をつけ、それを一つの単位として参照出来るようにする
- 例) 二乗の計算
  #+begin_src scheme
  (define (square x) (* x x))
  #+end_src
  - 複合手続き(compound procedure)を作り、それにsquareという名前をつけ
    ている。
  - この定義を評価すると、この複合手続きを作成し、それをsquareという名
    前と関連付ける

定義の書き方
#+begin_src scheme
(define (<名前> <仮引数>) <本体>)
#+end_src

- 名前
  - 環境の中で手続きに関連付ける記号
- 仮引数
  - 手続きの本体の中で対応する引数を参照するために使う名前
- 本体
  - その中に出てくる仮引数をその手続が適用される実際の引数で置き換えた
    場合に、手続き適用後の値を返すような式

- 定義された手続きは他の手続きを定義するための構成部品として使うことも可能
  #+begin_src scheme
  (+ (square x) (square y)) ;; x^2 + y^2 を表している
  #+end_src
  - sum-of-squares
  #+begin_src scheme
  (define (sum-of-squares x y)
    (+ (square x) (square y)))
  (sum-of-squares 3 4)
  #+end_src
  - さらに別の例
    #+begin_src sheme
    (define (f a)
      (sum-of-squares (+ a 1) (* a 2)))
    (f 5)
    136
    #+end_src

- 複合手続きは基本手続きとまったく同じように使うことが出来る

- (所感)
  - 複合手続きとは結局何だ、という定義ははっきり示されていない印象

*** 1.1.5 手続き適用後の置換モデル

- インタプリタによる評価
  - 組み合わせの各要素を評価し
  - 手続き（組み合わせの演算子の値）を引数（組み合わせの被演算子の値）に適用する
- 基本手続きを引数に適用する仕組みはインタプリタに組み込まれている
- 複合手続きを引数に適用する手順
  - 手続きの本体に出てくる仮引数を対応する引数で置き換えて
  - それを評価する
- 複合手続きの例: (f 5)
  - まずfの本体を取得する
    #+begin_src scheme
    (sum-of-squares (+ a 1) (* a 2))
    #+end_src
  - 次に仮引数であるaを引数5で置き換える
    #+begin_src scheme
    (sum-of-squares (+ 5 1) (* 5 2))
    #+end_src
  - sum-of-squaresの引数を得るために（sum-of-squaresの）2つの被演算子
    を評価し、評価結果値をsum-of-squares手続きの引数として適用する
    #+begin_src scheme
    (+ 5 1)
    6
    (* 5 2)
    10
    #+end_src
  - sum-of-squaresの仮引数を実際の値で置き換えて評価する
    #+begin_src scheme
    (sum-of-squares 6 10)
    -> (+ (square 6) (square 10))
    -> (+ (* 6 6) (* 10 10))
    -> (+ 36 100)
    136
    #+end_src
- 上記は手続き適用の置換モデル（substitution model）と呼ばれる
  - 手続き適用の”意味”を決めるモデルとして捉えられる
  - ただし置換モデルは最初の一歩（単純化した不完全なモデル）ということ
    に注意しておく（後の章でより深い議論があるらしい）

**** 適用順序と正規順序

- 前節とは別の評価方法
  - 値が必要になるまで被演算子を評価せず、代わりに被演算子の式を基本演
    算子しか出てこない式になるまで置き換えてから評価する。
- (f 5)での例
  #+begin_src scheme
  (sum-of-squares (+ 5 1) (* 5 2))
  (+ (square (+ 5 1)) (square (* 5 2)))
  (+ (* (+ 5 1) (+ 5 1)) (* (* 5 2) (* 5 2)))
  #+end_src
  それから次のように簡約される
  #+begin_src scheme
  (+ (* 6 6) (* 10 10))
  (+ 36 100)
  136
  #+end_src
- 正規順序評価 (normal-order evaluation)
  - "完全に展開してから簡約する"評価方法
  - 上記の例など
- 適用順序評価 (applicative-order evaluation)
  - "引数を評価してから適用する"評価方法
  - インタプリタが実際に使っている方法
- Lispは適用順序評価を使っている
  - (+ 5 1)や(* 5 2)のような複数回評価を避ける性能上の理由と
  - 置換によってモデル化出来る手続きの範囲を超えると正規順序評価はとて
    も複雑になってしまう、からだそう

*** 1.1.6 条件式と述語

- 場合分け（条件分岐）は cond を使う
  #+begin_src scheme
  (define (abs x)
    (cond ((> x 0) x)
          ((= x 0) 0)
          ((< x 0) (- x))))
  #+end_src
  
- 条件の一般形式
  #+begin_src scheme
  (cond (<p1> <e1>)
        (<p2> <e2>)
        ...
        (<pn> <en>))
  #+end_src
  - 記号condに続く、節(clause)と呼ばれる括弧でくくった式のペアの列によっ
    て構成される。節は (<p> <e>)の形式。
  - 節のそれぞれのペアの最初の式は述語(predicate, 値が真か偽かのどちら
    かとして解釈される式)
  
- 条件式の評価
  - 述語<p1>が評価される
  - もしその値が偽なら述語<p2>が評価される。値が真である述語が見つかるまで続く
  - 見つかるとその説に対応する結果式<e> (consequent expression) の値を返す
  - <p>のどれも真でない場合、condの値は未定義

- 述語(predicate)
  - 真か偽のどちらかに評価される式 or
  - 真か偽のどちらかを返す手続き

- 絶対値の別の定義
  #+begin_src scheme
  (define (abs x)
    (cond ((< x 0) (- x))
          (else x)))
  #+end_src
- elseはcondの最後の節の<p>の代わりに使える
  - それまでの全ての節が偽でスキップされたときに、これに対応する<e>を
    condの値として返す

- ifの使用例
  #+begin_src scheme
  (define (abs x)
    (if (< x 0)
        (- x)
        x))
  #+end_src
  - ifは場合分けがちょうど2つの場合に使える制約付き条件式
- ifの一般形式
  #+begin_src scheme
  (if <predicate> <consequent> <alternative>)
  #+end_src
  - 最初に<predicate>を評価し、
  - もし評価結果が真なら<consequent>を評価しその値を返す
  - そうでなければ<alternative>を評価しその値を返す
- 論理複合演算
  - and
    #+begin_src scheme
    (and <e1> ... <en>)
    #+end_src
  - or
    #+begin_src scheme
    (or <e1> ... <en>)
    #+end_src
  - not
    #+begin_src scheme
    (not <e>)
    #+end_src
- andとorは特殊形式であり、手続きではない
- notは通常の手続き

**** 練習問題1.1
#+begin_src scheme
10 => 10
(+ 5 3 4) => 12
(- 9 1) => 8
(/ 6 2) => 3
(+ (* 2 4) (- 4 6)) => 6
(define a 3) => ok
(define b (+ a 1)) => ok
(+ a b (* a b)) => 19
(= a b) => #f (false)
(if (and (> b a) (< b (* a b)))
    b
    a)
=> 4
(cond ((= a 4) 6)
      ((= b 4) (+ 6 7 a))
      (else 25))
=> 16
(+ 2 (if (> b a) b a)) => 6
(* (cond ((> a b) a)
         ((< a b) b)
         (else -1))
   (+ a 1))
=> 16
#+end_src

**** 練習問題1.2
#+begin_src scheme
(/ (+ 5
      4
      (- 2 (- 3 (+ 6 (/ 4 5)))))
   (* 3 (- 6 2) (- 2 7)))
#+end_src

**** 練習問題1.3
#+begin_src scheme
(define (square x) (* x x))
(define (sqadd x y) (+ (square x) (square y)))
(define (bigger x y) (if (> x y) x y))
(define (f x y z)
  (sqadd (if (> x y) x y)
         (if (> x y)
             (bigger y z)
             (bigger x z))))
#+end_src
なんか難しかった。

**** 練習問題1.4
#+begin_src scheme
(define (a-plus-abs-b a b)
  ((if (> b 0) + -) a b))
#+end_src
bが非負ならa+bで、bが負ならa-(-b)=a+bとなり、いずれにせよaとbの絶対値
の和になっている。

**** 練習問題1.5
#+begin_src scheme
(define (p) (p))
(define (test x y)
  (if (= x 0) 0 y))
#+end_src
上記をjakldで実行すると応答が帰ってこない。つまりtest手続きのif式の代
替式であるy（すなわち(p)）が評価されているということを表している。もし
正規順序評価であれば、(if (= 0 0) 0 (p))と展開される。この後はifの述語
式が評価され 0=0なので0が返されて終わる。（疑問点: (p)を展開しようとし
て無限ループに入ることはない？）逆に適用順序評価だと、(test 0 (p))の時
点で(p)を評価しようとして無限ループに入る気がする。自分の理解だと両方
とも結局無限ループにはいってしまう気がするが、どうなのだろう。。意図と
しては、おそらく正規順序評価では結果値が0となることを期待しているので
はないかと思われる。

*** 1.1.7 ニュートン法による平方根 
- 数学の関数とコンピュータの手続きは似ているが一つの重要な違いがある
  - 手続きは実効的なものでなければならないということ
  - 手続きでは実際にどうやって値を求めるかを示さないといけない
- 関数と手続きの違い
  - 関数: 物事の属性についての説明
  - 手続き: どうやって物事を行うかについての説明
- 宣言的記述(何であるか)
  - 数学的
- 命令的記述(どうやるか)
  - コンピュータサイエンス的

- ニュートン法
  #+begin_src scheme
  (define (sqrt-iter guess x)
    (if (good-enough? guess x)
        guess
        (sqrt-iter (improve guess x) x)))
  (define (improve guess x)
    (average guess (/ x guess)))
  (define (average x y)
    (/ (+ x y) 2))
  (define (good-enough? guess x)
    (< (abs (- (square guess) x)) 0.001))
  (define (sqrt x)
    (sqrt-iter 1.0 x))
  #+end_src

- sqrt-iterは、繰り返しを達成することは「手続きを呼ぶという通常の能力
  だけで出来る」ということの実例となっている

**** 練習問題1.6
Alyssa P. Hackerは、なぜifが特殊形式として提供される必要があるのか理解
できなかった。"condを使って普通の手続きとして定義したらいんじゃないの"
と彼女は質問した。Alyssaの友達である Eva Lu Atorは、これは実際に出来る
と主張し、ifの新しいバージョンを定義した。
#+begin_src scheme
(define (new-if predicate then-clause else-clause)
  (cond (predicate then-clause)
        (else else-clause)))
#+end_src
EvaはAlyssaにプログラムのデモを行った。
#+begin_src scheme
(new-if (= 2 3) 0 5)
5
(new-if (= 1 1) 0 5)
0
#+end_src
喜びながら、Alyssaはnew-ifを使って平方根のプログラムを書き直した。
#+begin_src scheme
(define (sqrt-iter guess x)
  (new-if (good-enough? guess x)
          guess
          (sqrt-iter (improve guess x) x)))
#+end_src
Alyssaが平方根の計算をするのにこれを使おうとすると、何が起こるだろうか。
説明せよ。

*回答*
実際に実行してみると、以下のようにstack overflowが発生してしまう。
#+begin_src scheme
>(sqrt 9)
StackOverflowError
Backtrace: good-enough? < sqrt-iter < sqrt-iter < sqrt-iter < sqrt-iter ...
... < sqrt-iter < [sqrt] < top-level
#+end_src

なぜこうなるかの考察は以下の通り。
まずnew-ifを使う場合で(sqrt 9)を実行したとすると、以下のように展開される。
#+begin_src scheme
(sqrt 9)
=> (sqrt-iter 1.0 9)
=> (new-if (good-enough? 1.0 9)
           10
           (sqrt-iter (improve 1.0 9) 9))
#+end_src
インタプリタは適用順序評価で動作するので、new-ifの 被演算子である
good-enough?とsqrt-iter（とその被演算子のimprove）を評価しようとする。
good-enough?とimproveは基本式になるので良いが、sqrt-iterは再度new-ifを
呼び出すので、結局Stack overflowになるまで無限ループになってしまう。こ
れはnew-ifが特殊形式でないため、適用順序評価では被演算子を先に評価して
しまうことが原因である。一方、特殊形式としてのifは、かならず最初に述語
式を評価し、その評価結果に応じて結果式もしくは代替式を評価する、という
動作になるのでsqrt-iterが無限ループに陥らなくて済む。


**** 練習問題1.7
割愛。

**** 練習問題1.8
割愛。

*** 1.1.8 ブラックボックス抽象化としての手続き

- sqrtは相互に定義された手続きのセットとして定義されるプロセスの最初の例
  - (コメント)手続きとプロセスの違いは？
    - プロセス: データを操作する（精霊みたいな）抽象的な存在
    - 手続き: データを操作するための規則を記述したもの
    - (引田所感) プロセスは人間でいうと魂に相当するのではないかと思う。
      魂自体は物質的に存在しないが、外部からの様々なデータ（五感による
      入力）から自分という肉体がどういうふうに振る舞うかを操作する。

- sqrt-iterの定義は再帰的(recursive)
  - (手続きが)それ自身を使って定義されているということ
  - 再帰的定義の正当性については1.2節で詳しく議論する（のでここでは深
    く考察しない）
- 平方根を計算するという問題は自然にいくつかの部分問題に分割されている
  - 推定値が十分によいかどうやって判断するか
  - どうやって推定値を改善するか、等
- sqrtプログラム全体は図1.2に示すような手続きの塊として見ることが出来る
  #+begin_src
  (sqrt (sqrt-iter
           (good-enough square
                        abs)
           (improved average)))
  #+end_src
- 分解戦略の重要点
  - それぞれの手続が特定のタスクを成し遂げていてそれが他の手続きを定義
    する際にもモジュールとして使えるようになっていること
  - good-enough?手続きからみると、squareは手続きというより手続きを抽象化（手続き抽象）したもの
    - 二乗を計算する手続きの具体的な処理内容は無視できる
- 手続き定義は詳細を隠せるようになっていなければならない

**** 局所名

- 手続きの意味はその作者が使った仮引数の名前とは独立であるべき。以下の
  2つの手続きは区別不可能であるべき。つまり両方とも評価結果は同じであ
  り、仮引数の名前がxやyと異なっていてもそれは評価値に影響しない
  #+begin_src scheme
  (define (square x) (* x x))
  (define (square y) (* y y))
  #+end_src
- 手続きの仮引数の名前は手続き本体内に局所化されているべき
- 仮引数がそれぞれの手続きの本体に局所化されていなかったとすると、ある
  手続きA（例えばsquare）を利用する手続きB（例えばgood-enough?）は、手
  続きAのバージョンに依存する（Aが利用する仮引数の名前と衝突しないよう
  に注意しないといけなくなる）ので、手続きBはブラックボックスではなく
  なってしまう。

- 束縛変数(bounded variable)
  - 手続き定義の仮引数
  - 束縛変数が手続きの中で一貫性を持って改名された場合、手続きの意味は
    変わらない
- 自由変数(free variable)
  - 束縛変数でない変数
- （名前の）スコープ(scope)
  - 束縛によって名前が定義される式のセット
  - 手続き定義においてはその手続きの仮引数として宣言された束縛変数はそ
    の手続き本体をスコープとして持つ
 
**** 内部定義とブロック構造

- ブロック構造(block structure)
  - 名前を（手続きから）分離する方法の一つ
  - 定義のネスト
    - defineの中で別のdefineを書く
  - 手続きが局所的な内部定義を持てるようにし、
  - 束縛変数はそのスコープ内でならどこからでも参照可能
    - sqrtのxは内部定義のgood-enough?やimprove, sqrt-iterに明示的に渡
      す必要はない
- レキシカルスコーピング(lexical scoping)
  - (脚注より) 手続きの自由変数はその手続きを包む手続き定義の束縛を参
    照する、と規定される
    - 手続きが定義された環境での探索が行われる
    - 内部定義(例えばgood-enough?,improve, sqrt-iter)では外部定義
      (sqrt)の束縛変数を自由変数として扱う
    - その変数（sqrtにおけるx）の値は、それを囲む手続き（例ではsqrt）
      の引数から取ってくる事ができる
- レキシカルスコーピングを用いたsqrtの実装例
  #+begin_src scheme
  (define (square x) (* x x))
  (define (average x y) (/ (+ x y) 2))
  (define (sqrt x)
    (define (good-enough? guess)
      (< (abs (- (square guess) x)) 0.001))
    (define (improve guess)
      (average guess (/ x guess)))
    (define (sqrt-iter guess)
      (if (good-enough? guess)
          guess
          (sqrt-iter (improve guess))))
    (sqrt-iter 1.0))
  #+end_src
  - (引田所感) この(sqrt-iter 1.0)部分はsqrt定義の評価時に実行されてし
    まわないのだろうか？遅延評価とかにつながるのかな？この時点では何も
    言及がないけど。


