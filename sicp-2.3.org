#+TITLE: SICP 2.3 記号データ

この節では任意の記号をデータとして扱う能力を導入して言語の表現能力を拡張する。

* 2.3.1 クォート
記号を使って複合データを作れるとしたら以下のようなリストが使えることになる
#+BEGIN_SRC scheme
(a b c d)
(23 45 17)
((Norah 12) (Molly 9) (Anna 7) (Lauren 6) (Charlotte 4))
#+END_SRC

記号を含むリストは我々の言語の次のような式と同じように見える
#+BEGIN_SRC scheme
(* (+ 23 45) (+ x 9))
(define (fact n) (if (= n 1) 1 (* n (fact (- n 1)))))
#+END_SRC

- 記号の操作するためには、データオブジェクトを *クォート(quote)* する。
- クォートは自然言語である語句そのものを扱いたいときに使われる慣例で、Schemeでもそれを踏襲する。
- クォートにより、リストや記号について、式として評価の対象にするのではなく、データオブジェクトとして扱うことが出来るようになる。
- Schemeではクォートするオブジェクトの前に単一引用符(') をひとつだけ置く。
  - シングルクォートは次のオブジェクトをクォートするという意味になっている

#+BEGIN_SRC scheme
(define a 1)
(define b 2)
(list a b)
> (1 2)
(list 'a 'b)
> (a b)
(list 'a b)
> (a 2)

(car '(a b c))
> a
(cdr '(a b c))
> (b c)
'()
> () ;; これで空リストが得られるので以降は変数nilは不要
#+END_SRC

*（脚注34）について*
- 引用符は次に来る完全な式を quoteを使って包んで、 (quote <expression>) を作るということを一文字に省略したものにすぎない
  - e.g.)
    - ~'a <=> (quote a)~
    - ~'(a b c) <=> (quote (a b c))~
#+BEGIN_SRC scheme
;; (car '(a b c)) という式は以下を評価することで構築出来る
(list 'car (list 'quote '(a b c)))
-> (list (quote car) (list (quote quote) (quote (a b c)))) ;; 適用順序評価だとquoteを先に評価してしまいそいうだが、quoteは特殊形式だから遅延評価されるのかな？そういう想定だと下の簡約は納得できる
-> ((quote car) ((quote quote) (quote (a b c))))
-> (car (quote (a b c))) ;; 元の式と等価
#+END_SRC

~eq?~ について
- 2つの記号を引数にとり、それが同じであるかどうかをテストする

eq?を使うと ~memq~ 手続きを実装出来る。
- *memq*: 記号とリストを引数にとり、記号がリストにふくまれていなければ
  memqは偽を返し、そうでなければそのリスト中で記号が最初に見つかったと
  ころから始まるサブリストを返す
#+BEGIN_SRC scheme
(define (memq item x)
  (cond ((null? x) #f) ;; false -> #f に修正
        ((eq? item (car x)) x)
        (else (memq item (cdr x)))))

;; 動作例
(memq 'apple '(pear banana prune)) ;; expected to #f
> #f
(memq 'apple '(x (apple sauce) y apple pear)) ;; expected to (apple pear)
> (apple pear) ;; (apple sauce)はappleとは等しくない
#+END_SRC

クォートの（まだ完全に理解できていないので）不思議な動き
#+BEGIN_SRC 
gosh> 'ab'cd
ab
gosh> cd
#+END_SRC

** 練習問題
*** 練習問題 2.53
回答&動作確認
#+BEGIN_SRC scheme
(list 'a 'b 'c) ;; expected (a b c)
> (a b c)
(list (list 'george)) ;; expected ((george))
> ((george))
(cdr '((x1 x2) (y1 y2))) ;; expected ((y1 y2))
> ((y1 y2))
(cadr '((x1 x2) (y1 y2))) ;; expected (y1 y2)
> (y1 y2)
(pair? (car '(a short list))) ;; expected #f
> #f
(memq 'red '((red shoes) (blue socks))) ;; expected #f
> #f
(memq 'red '(red shoes blue socks)) ;; expected (red shoes blue socks)
> (red shoes blue socks)
#+END_SRC

#+BEGIN_SRC scheme
(eq? '(a b c) (list 'a 'b 'c))
> #f
(equal? '(a b c) (list 'a 'b 'c))
> #t
#+END_SRC
*** 練習問題 2.54 equals?の実装

回答
#+BEGIN_SRC scheme
(define (equal? a b)
  (cond ((eq? a b) #t)
        ((and (pair? a) (pair? b))
           (and (equals? (car a) (car b))
                (equals? (cdr a) (cdr b))))
        (else #f)))
#+END_SRC

動作確認
#+BEGIN_SRC scheme
(equal? '(this is a list) '(this is a list)) ;; expected to #t
> #t
(equal? '(this is a list) '(this (is a) list)) ;; expected to #f

(equal? '(this is a list) '()) ;; expected to #f
> #f
(equal? '() '()) ;; expected to #t
> #t
(equal? 'a 1) ;; expected to #f
> #f
(equal? 1 1) ;; expected to #t
> #t
#+END_SRC

*** 練習問題 2.55

以下の式がquoteを返すことの説明
#+BEGIN_SRC scheme
(car ''abracadabra)
> 
#+END_SRC

回答
- シングルクォート（'<exp>）は内部で特殊形式 ~(quote <exp>)~ という形に変形され、一番先頭（外側）のquoteのみが評価される（と思われる）
  - つまり特殊形式なので適用順序評価（手続きの引数を先に評価する）とは違う評価結果となる。
- 最初に ~''abracadabra~ は ~(quote (quote abracadabra))~ として評価され、最初のquoteが評価された段階でcarに渡される。
- carが評価するのは ~(quote abracadabra)~ ということになるので、~quote~ が表示される
#+BEGIN_SRC scheme
;; 置換モデルで考えると以下の挙動になる
(car ''abracadabra)
(car (quote (quote abracadabra))) ;; quoteは特殊形式なので、おそらく一番外側のquoteのみが評価される
(car (quote abracadabra))
quote
#+END_SRC

(2020/12/19 追記)
上の回答は一部違っている気がする。クォートが(quote ...)に展開されても評価自体はまだされていないと思われる。
つまり、 ~(car ''abra)~ は ~(car (quote (quote abra)))~ になって、carの値が ~quote~ ということなんじゃないだろうか。
以下それを確認するためのテスト
#+BEGIN_SRC scheme
  ;; assuming ''abra as (quote (quote abra))
  (car ''abra) ;; expected to quote
  > quote
  (cdr ''abra) ;; expected to ((quote abra))
  > (abra) ;; なんで？
  (cadr ''abra) ;; expected to quote
  > abra   ;; なんで？

  ;; 数値の演算手続きで確認
  (car '(+ (* 3 2) 1)) ;; expected to +
  > +
  ;; もしcdrで取り出すリストの先頭要素が手続きだったらその評価結果が返さ
  ;; れる挙動の場合、以下は(6 1)が返る。もしリストの先頭要素が手続きでも
  ;; cdrで取り出すだけなら評価されないという場合、((* 3 2) 1) が返るはず。
  (cdr '(+ (* 3 2) 1)) ;; expected to (6 1) or ((* 3 2) 1)
  > ((* 3 2) 1)
#+END_SRC
この解釈はやっぱり違う。

おそらく最初の解釈の方が正しいのかもしれない。Schemeのドキュメント
([[http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_sec_11.4.1][r6rs]])の11.4.1では以下のように書いてある。
#+BEGIN_SRC 
11.4.1  Quotation
(quote <datum>)‌‌syntax 
Syntax: <Datum> should be a syntactic datum.

Semantics: (quote <datum>) evaluates to the datum value represented by <datum> (see section 4.3). This notation is used to include constants.
#+END_SRC

quoteは特殊形式で、引数を適用順序で単純には評価しないのはその通りで、
#+BEGIN_SRC scheme
'aaa
aaa

''aaa
(quote aaa)

'''aaa
(quote (quote aaa))
#+END_SRC
となる。つまり、上記は
#+BEGIN_SRC scheme
(car 'aaa)
(car (quote aaa))
(car aaa)
aaa

(car ''aaa)
(car (quote (quote aaa)))
(car (quote aaa)) ;; quoteの評価結果なのでこのcarの引数はこれ以上評価されない
quote

(car '''aaa)
(car (quote (quote (quote aaa))))
(car (quote (quote aaa))) ;; quoteの評価結果なのでこのcarの引数はこれ以上評価されない
quote
#+END_SRC
となる。

他の例は
#+BEGIN_SRC scheme
(cdr 'aaa)
(cdr (quote aaa))
(cdr aaa) ;; expected to error
gosh> (cdr 'aaa)
*** ERROR: pair required, but got aaa
Stack Trace:
_______________________________________
  0  (cdr 'aaa)
        at "(standard input)":104
  1  (eval expr env)
        at "/usr/local/Cellar/gauche/0.9.9/share/gauche-0.97/0.9.9/lib/gauche/interactive.scm":269
;; 予想通りエラーになった。pairを想定しているのにaaaが渡されている

(cdr ''aaa)
(cdr (quote (quote aaa)))
(cdr (quote aaa))
(aaa) ;; goshで確認済み

(cdr '''aaa)
(cdr (quote (quote (quote aaa))))
(cdr (quote (quote aaa)))
((quote aaa)) ;; goshで確認済み

;; 番外編

''aa'aa ;; これは
(quote (quote aa (quote aa)))
(quote aa (quote aa)) ;; ではなく、

''aa 'aa ;; と解釈されるみたい
(quote (quote aa))
(quote aa) ;; １つ目の結果

(quote aa)
aa         ;; ２つ目の結果
;; 以下gaucheでの実行結果。上記の動きになっている。
gosh> ''aa'aa
(quote aa)
gosh> aa
#+END_SRC

クォートは連続しているとquote手続きのネストとして扱われるが、間に何か
別の記号等が入ると別々のクォートとして認識されるようだ。

これはどうか
#+BEGIN_SRC scheme
''aa('aa) ;; -> error (aa)は不正な適用と怒られる
''aa'(aa) ;; -> (quote aa) と (aa) になる。
#+END_SRC

*最終回答*

- ~'~ は 特殊形式 ~(quote)~ の糖衣構文なので、 ~'<expression>~ は ~<expression>~ という評価結果となる。
- quoteは特殊形式なので、その引数は評価されずにそのままquoteに渡される（適用順序評価どおりには評価されない）
- そうすると、 ~''abra~ は ~(quote (quote abra))~ となり、外側のquoteだけが評価され ~(quote abra)~ となる。
- 上記がcarに渡されるので、 ~(car (quote abra))~ となりその評価結果は ~quote~ になる。
  - carの引数は一番外側のquoteの結果なので、さらにquoteが評価されることはない


備考
#+BEGIN_SRC scheme
'(a b c)
(quote (a b c))
(a b c)

(list 'a 'b 'c)
(list (quote a) (quote b) (quote c))
(list a b c)
(a b c)

(list ''a ''b ''c)
(list (quote (quote a)) (quote (quote b)) (quote (quote c)))
(list (quote a) (quote b) (quote c))
((quote a) (quote b) (quoate c))

(list '(+ 1 2) 3)
(list (quote (+ 1 2)) 3)
(list (+ 1 2) 3)
((+ 1 2) 3)
#+END_SRC

* 2.3.4 例: 記号微分

記号操作、データ抽象化の別の例として、代数式の記号微分を行う手続きの設計について考える。

手続きは
- 引数として代数式と変数をとる
- その変数に関するその式の導関数を返す
とする。

記号微分プログラムは、有理数システム（2.1.1節）と同じデータ抽象化戦略に従う
- まず和、積、変数といった抽象オブジェクトの上で動く微分アルゴリズムを定義するところからはじめる
- それら抽象オブジェクトがどのように表現されるべきかは（最初は）考えない

** 抽象データによる微分プログラム

以下を踏まえてセレクタ、コンストラクタ、述語を実装する手続きができているとする
- もし代数式の表現手段があるとするなら、ある式が和なのか積なのか定数なのか変数なのか識別できるはず
- また式から構成要素を抽出することもできるはず
- 構成要素から式を構築することもできるはず
#+BEGIN_SRC scheme
(variable? e)          ;; eは変数か？         述語
(same-variable? v1 v2) ;; v1とv2は同じ変数か？ 述語
(sum? e)               ;; eは和か？           述語
(addend e)             ;; 和eの加数（第一項）  selector
(augend e)             ;; 和eの被加数（第二項） selector
(make-sum a1 a2)       ;; a1とa2の和を構築する constructor
(product? e)           ;; eは積か？           述語
(multiplier e)         ;; 積eの乗数           selector
(multiplicand e)       ;; 積eの被乗数         selector
(make-product m1 m2)   ;; m1とm2の積を構築する constructor
#+END_SRC

上記と ~number?~ （数値かどうかを判断する基本述語）を使って微分規則を ~derive~ 手続きとして表現する。
- 抽象データによって表現されているので、正しくセレクタとコンストラクタを設計する限り代数式をどう表現しても動くはず。
#+BEGIN_SRC scheme
(define (deriv exp var)
  (cond ((number? exp) 0)
        ((variable? exp) (if (same-variable? exp var) 1 0))
        ((sum? exp) (make-sum (deriv (addend exp) var)
                              (deriv (augend exp) var)))
        ((product? exp)
         (make-sum
           (make-product (multiplier exp)
                         (deriv (multiplicand exp) var))
           (make-product (deriv (multiplier exp) var)
                         (multiplicand exp))))
        (else
          (error "unknown expression type: DERIV" exp))))
#+END_SRC

動作例
#+BEGIN_SRC scheme
TBD
#+END_SRC

** 代数式を表現する

Lispと同じように括弧で括った前置記法を使うとすると、微分問題に対するデータ表現は次のようになる。
#+BEGIN_SRC scheme
;; 変数は記号である。基本述語symbol?で識別する 
(define (variable? x) (symbol? x))

;; 二つの変数は、それらを表現する記号がeq?であれば等しい
(define (same-variable? v1 v2)
  (and (variable? v1) (variable? v2) (eq? v1 v2)))

;; 和と積は、リストとして構築する
(define (make-sum a1 a2) (list '+ a1 a2)) ;; (+ a1 a2) ここでquoteが使われている
(define (make-product m1 m2) (list '* m1 m2))

;; 和は、最初の要素が記号+であるリストである
(define (sum? x) (and (pair? x) (eq? (car x) '+)))

;; 加数は、和のリストの二つ目の項である (+ a1 a2) の a1
(define (addend s) (cadr s))

;; 被加数は、和のリストの三つ目の項である (+ a1 a2) の a2
(define (augend s) (caddr s))

;; 積は、最初の要素が記号*であるリストである
(define (product? x) (and (pair? x) (eq? (car x) '*)))

;; 乗数は、積のリストの二つ目の項である
(define (multiplier p) (cadr p))

;; 被乗数は、積のリストの三つ目の項である
(define (multiplicand p) (caddr p))
#+END_SRC

derivの動作確認
#+BEGIN_SRC scheme
(deriv '(+ x 3) 'x)
> (+ 1 0)
(deriv '(* x y) 'x)
> (+ (* x 0) (* 1 y))
(deriv '(* (* x y) (+ x 3)) 'x)
> (+ (* (* x y) (+ 1 0)) (* (+ (* x 0) (* 1 y)) (+ x 3)))
#+END_SRC

値は正しいが答えが最も単純な形に簡約されていない。
この問題への対処にはderivには手を加えないで、各種constructorに変更を加える。

まずmake-sumに変更を加える
  - 両方の加数が数値であれば、それらを足し合わせて和を返す
  - 加数の1つが0であればもう一つの加数のみを返す
#+BEGIN_SRC scheme
(define (=number? exp num) (and (number? exp) (= exp num)))

(define (make-sum a1 a2)
  (cond ((=number? a1 0) a2)
        ((=number? a2 0) a1)
        ((and (number? a1) (number? a2)) (+ a1 a2))
        (else (list '+ a1 a2))))
#+END_SRC

同様にmake-productに変更を加え
- 0には何を掛けても0で
- 1に何かを掛けてるとその何か自身になる
という規則を加える
#+BEGIN_SRC scheme
(define (make-product m1 m2)
  (cond ((or (=number? m1 0) (=number? m2 0)) 0)
        ((=number? m1 1) m2)
        ((=number? m2 1) m1)
        ((and (number? m1) (number? m2)) (* m1 m2))
        (else (list '* m1 m2))))
#+END_SRC

先程の三つの例は以下のようになる。
#+BEGIN_SRC scheme
(deriv '(+ x 3) 'x)
> 1
(deriv '(* x y) 'x)
> y
(deriv '(* (* x y) (+ x 3)) 'x)
> (+ (* x y) (* y (+ x 3)))
#+END_SRC

** 練習問題
*** 練習問題 2.56 微分規則の追加

回答
#+BEGIN_SRC scheme
;; preliminary
(define (exponentiation? x) (and (pair? x) (eq? (car x) '**)))
(define (make-exponentiation base exponent)
  (cond ((=number? exponent 0) 1)
        ((=number? exponent 1) base)
        (else (list '** base exponent))))
(define (base exp) (cadr exp))
(define (exponent exp) (caddr exp))

;; enhanced deriv
(define (deriv exp var)
  (cond ((number? exp) 0)
        ((variable? exp) (if (same-variable? exp var) 1 0))
        ((sum? exp) (make-sum (deriv (addend exp) var)
                              (deriv (augend exp) var)))
        ((product? exp)
         (make-sum
           (make-product (multiplier exp)
                         (deriv (multiplicand exp) var))
           (make-product (deriv (multiplier exp) var)
                         (multiplicand exp))))
        ((exponentiation? exp)
         (make-product
           (exponent exp)
           (make-product
             (make-exponentiation (base exp) (- (exponent exp) 1))
             (deriv (base exp) var))))
        (else
          (error "unknown expression type: DERIV" exp))))
#+END_SRC

動作確認
#+BEGIN_SRC scheme
;; test for exponentiation
(make-exponentiation 2 0) ;; expected to 1
> 1
(make-exponentiation 2 1) ;; expected to 2
> 2
(deriv '(** x 0) 'x) ;; expected to 0?
(deriv '(** x 1) 'x) ;; expected to 1
(deriv '(** x 4) 'x) ;; expected to (* 4 (** x 3))
> (* 4 (** x 3))
#+END_SRC

*** 練習問題 2.57 任意の数の項の和と積への拡張

回答
#+BEGIN_SRC scheme
;; 補助関数
(define (=number? exp num) (and (number? exp) (= exp num)))
(define (deriv exp var)  ;; derivには手を加えない
  (cond ((number? exp) 0)
        ((variable? exp) (if (same-variable? exp var) 1 0))
        ((sum? exp) (make-sum (deriv (addend exp) var)
                              (deriv (augend exp) var)))
        ((product? exp)
         (make-sum
           (make-product (multiplier exp)
                         (deriv (multiplicand exp) var))
           (make-product (deriv (multiplier exp) var)
                         (multiplicand exp))))
        ((exponentiation? exp)
         (make-product
           (exponent exp)
           (make-product
             (make-exponentiation (base exp) (- (exponent exp) 1))
             (deriv (base exp) var))))
        (else
          (error "unknown expression type: DERIV" exp))))
(define (make-sum a1 a2)
  (cond ((=number? a1 0) a2)
        ((=number? a2 0) a1)
        ((and (number? a1) (number? a2)) (+ a1 a2))
        (else (list '+ a1 a2))))
(define (make-product m1 m2)
  (cond ((or (=number? m1 0) (=number? m2 0)) 0)
        ((=number? m1 1) m2)
        ((=number? m2 1) m1)
        ((and (number? m1) (number? m2)) (* m1 m2))
        (else (list '* m1 m2))))

;;==== 本回答 ====
;; (define (augend s) (cddr s))
;; (define (multiplicand p) (caddr p))
(define (augend s)
  (if (null? (cdddr s))
      (caddr s)
      (append (list '+) (cddr s))))
(define (multiplicand p)
  (if (null? (cdddr p))
      (caddr p)
      (append (list '*) (cddr p))))
#+END_SRC

動作確認
#+BEGIN_SRC scheme
(augend '(+ a b))       ;; expected to b
> b
(augend '(+ a b c))     ;; expected to (+ b c)
> (+ b c)
(augend '(+ a b c d))   ;; expected to (+ b c d)
> (+ b c d)

(multiplicand '(* a b)) ;; expected to b
> b
(multiplicand '(* a b c)) ;; expected to (* b c)
> (* b c)
(multiplicand '(* a b c d)) ;; expected to (* b c d)
> (* b c d)

(deriv '(+ x 3) 'x) ;; expected to 1
> 1
(deriv '(* x y) 'x) ;; expected to y
> y
(deriv '(* x y (+ x 3)) 'x) ;; expected to (+ (* x y) (* y (+ x 3)))
> (+ (* x y) (* y (+ x 3)))
#+END_SRC

練習
#+BEGIN_SRC scheme
;; 可変長引数ではa2はリストになっている。a2の要素が一つだけでもちゃんとリストになっている
(define (ms a1 . a2) (append (list a1) a2))
(ms 'a 'b 'c)
> (a b c)
(define (ms a1 . a2) a2)
(ms 'a 'b 'c)
> (b c)
(ms 'a 'b)
> (b)
#+END_SRC

適切なコンストラクタとセレクタが設計できていれば修正はごく一部分のみで済む

*** 練習問題 2.58

代数式を表現する述語、セレクタ、コンストラクタを変更するだけで異なる表現を扱うように修正する。

**** a. 中置記法での代数式の微分

微分プログラム
#+BEGIN_SRC scheme
(define (=number? exp num) (and (number? exp) (= exp num)))
(define (deriv exp var)  ;; derivには手を加えない
  (cond ((number? exp) 0)
        ((variable? exp) (if (same-variable? exp var) 1 0))
        ((sum? exp) (make-sum (deriv (addend exp) var)
                              (deriv (augend exp) var)))
        ((product? exp)
         (make-sum
           (make-product (multiplier exp)
                         (deriv (multiplicand exp) var))
           (make-product (deriv (multiplier exp) var)
                         (multiplicand exp))))
        ((exponentiation? exp)
         (make-product
           (exponent exp)
           (make-product
             (make-exponentiation (base exp) (- (exponent exp) 1))
             (deriv (base exp) var))))
        (else
          (error "unknown expression type: DERIV" exp))))
(define (make-sum a1 a2)
  (cond ((=number? a1 0) a2)
        ((=number? a2 0) a1)
        ((and (number? a1) (number? a2)) (+ a1 a2))
        (else (list '+ a1 a2))))
(define (make-product m1 m2)
  (cond ((or (=number? m1 0) (=number? m2 0)) 0)
        ((=number? m1 1) m2)
        ((=number? m2 1) m1)
        ((and (number? m1) (number? m2)) (* m1 m2))
        (else (list '* m1 m2))))
#+END_SRC

元々の述語、セレクタ、コンストラクタ
#+BEGIN_SRC scheme
;; procedures for variables
(define (variable? x) (symbol? x))
(define (same-variable? v1 v2)
  (and (variable? v1) (variable? v2) (eq? v1 v2)))

;; procedures for sum
(define (sum? x) (and (pair? x) (eq? (car x) '+)))
(define (make-sum a1 a2) (list '+ a1 a2))          ;; constructor
(define (addend s) (cadr s))                       ;; selector: (+ a b) => a
(define (augend s) (caddr s))                      ;; selector: (+ a b) => b

;; procedures for multiplication
(define (product? x) (and (pair? x) (eq? (car x) '*)))
(define (make-product m1 m2) (list '* m1 m2))      ;; constructor
(define (multiplier p) (cadr p))                   ;; selector: (* a b) => a
(define (multiplicand p) (caddr p))                ;; selector: (* a b) => b
#+END_SRC

回答
#+BEGIN_SRC scheme
;; procedures for sum
(define (sum? x) (and (pair? x) (eq? (cadr x) '+)))
(define (addend s) (car s))                        ;; selector: (a + b) => a
(define (augend s) (caddr s))                      ;; selector: (a + b) => b
(define (make-sum a1 a2)                           ;; constructor
  (cond ((=number? a1 0) a2)
        ((=number? a2 0) a1)
        ((and (number? a1) (number? a2)) (+ a1 a2))
        (else (list a1 '+ a2))))

;; procedures for multiplication
(define (product? x) (and (pair? x) (eq? (cadr x) '*)))
(define (multiplier p) (car p))                     ;; selector: (a * b) => a
(define (multiplicand p) (caddr p))                 ;; selector: (a * b) => b
(define (make-product m1 m2)                        ;; constructor
  (cond ((or (=number? m1 0) (=number? m2 0)) 0)
        ((=number? m1 1) m2)
        ((=number? m2 1) m1)
        ((and (number? m1) (number? m2)) (* m1 m2))
        (else (list m1 '* m2))))
#+END_SRC

動作確認
#+BEGIN_SRC scheme
;; for sum test
(sum? '(a + b)) ;; expected to #t
(sum? '(+ b c)) ;; expected to #f
(make-sum 'a 'b) ;; expected to (a + b)
(addend '(a + b)) ;; expected to a
(augend '(a + b)) ;; expected to b

;; for multiplication test
(product? '(a * b)) ;; expected to #t
(product? '(* a b)) ;; expected to #f
(make-product 'a 'b) ;; expected to (a * b)
(multiplier '(a + b)) ;; expected to a
(multiplicand '(a + b)) ;; expected to b

;; deriv test
(deriv '(x + 3) 'x) ;; expected to 1
(deriv '(x * y) 'x) ;; expected to y
(deriv '((x * y) * (x + 3)) 'x) ;; expected to ((x * y) + (y * (x + 3)))
#+END_SRC

**** b. 標準的な代数記法への拡張

出来なそう。

* 2.3.3 例: 集合を表現する

- 集合の表現は（代数式のリスト表現に比べ）あまり明らかではない
- 集合とはただの異なるオブジェクトの集まり
- 集合に使われる演算を規定することによって（データ抽象化の手法をつかうことによって）”集合”を定義できる

集合の演算
- *union-set*: 二つの集合の和集合を返す
- *intersection-set*: 二つの集合の共通部分を返す
- *element-of-set?*: 与えられた要素が集合の構成要素であるかどうかを判定する述語
- *adjoin-set*: オブジェクトと集合を引数にとり、オブジェクトを集合に追加してその集合を返す

データ抽象化という視座から見ると、上の解釈と整合性があるものでさえあれば、これらの演算を実装するのにどのような表現でも自由に設計できる

** 順序なしリストとしての集合

集合の表現手段（の一つ）
- 要素が2回以上現れることがないリスト
- 空集合は空リスト

まず最初にelement-of-set?を実装する。
#+BEGIN_SRC scheme
(define  (element-of-set? x set)
  (cond ((null? set) #f)
        ((equal? x (car set)) #t)
        (else (element-of-set? x (cdr set)))))
#+END_SRC


#+BEGIN_SRC 
（補足）
SICPでeq?ではなくequal?を使っているため、集合の要素は記号である必要はないと言っている。
これはどういうことか？

eq?はobj1とobj2がメモリ上で同じオブジェクトを表しているかをテストする。equalはリスト等では再帰的に対応する要素同士をequal?で比較する。リスト同士でなければeqv?と同じになる。
eqv?はobj1とobj2が数値や文字列の場合はその値が正確に等しいかをテストし、それら以外の比較の場合はeq?と同じテストを行う。

ので、equal?で各集合要素とxをeqv?で比較するということになる。だとしてもまだ「集合の要素は記号である必要はない」理由は腹落ち出来ていない。
#+END_SRC

element-of-set?を使ってadjoin-setを書ける。
#+BEGIN_SRC scheme
(define (adjoin-set x set)
  (if (element-of-set? x set)
      set
      (cons x set)))
#+END_SRC

intersection-setは再帰的な戦略を使う。
- もしset2とset1のcdrとの共通部分を作ることが出来るなら、set1のcarをそれに含めるかどうかを決めるだけで十分
- これは(car set1)がset2にも含まれているかどうかによって決まる
つまりset1のcarがset2に含まれるなら、それは共通要素になるはずなので、
それを含めた上で(cdr set1)とset2のintersectionを再帰的に計算していく。
もし、(car set1)がset2に含まれていないなら、(car set1)は無視して良いの
で、(cdr set1)とset2についてintersectionを再帰的に計算していけば良い。
#+BEGIN_SRC scheme
(define (intersection-set set1 set2)
  (cond ((or (null? set1) (null? set2)) '())
        ((element-of-set? (car set1) set2)
         (cons (car set1) (intersection-set (cdr set1) set2)))
        (else (intersection-set (cdr set1) set2))))
#+END_SRC

** 練習問題
*** 練習問題 2.59 union-set演算の実装

解き方はintersection-setと同じように考えられる。
- もしset2と(cdr set1)の和集合が作れるなら、(car set1)をそれに含めるかを決める
- これは(car set1)がset2に含まれていなければ和集合に追加し、そうでなければ(car set1)は無視すれば良い

回答
#+BEGIN_SRC scheme
(define (union-set set1 set2)
  (cond ((null? set1) set2)
        ((element-of-set? (car set1) set2)
         (union-set (cdr set1) set2))
        (else (cons (car set1) (union-set (cdr set1) set2)))))
#+END_SRC

動作確認
#+BEGIN_SRC scheme
(union-set '() '()) ;; expected to ()
> ()
(union-set '(1 2) '(3 4 5)) ;; expected to (1 2 3 4 5) 順不同
> (1 2 3 4 5)
(union-set '(1) '(1 2 3)) ;; expected to (1 2 3)
> (1 2 3)
(union-set '(1 2) '(1 2 3)) ;; expected to (1 2 3)
> (1 2 3)
(union-set '() '(1 2)) ;; expected to (1 2)
> (1 2)
#+END_SRC

*** 練習問題 2.60 重複集合

ここまでの集合演算
#+BEGIN_SRC scheme
(define  (element-of-set? x set)
  (cond ((null? set) #f)
        ((equal? x (car set)) #t)
        (else (element-of-set? x (cdr set)))))
(define (adjoin-set x set)
  (if (element-of-set? x set)
      set
      (cons x set)))
(define (intersection-set set1 set2)
  (cond ((or (null? set1) (null? set2)) '())
        ((element-of-set? (car set1) set2)
         (cons (car set1) (intersection-set (cdr set1) set2)))
        (else (intersection-set (cdr set1) set2))))
(define (union-set set1 set2)
  (cond ((null? set1) set2)
        ((element-of-set? (car set1) set2)
         (union-set (cdr set1) set2))
        (else (cons (car set1) (union-set (cdr set1) set2)))))
#+END_SRC

回答
#+BEGIN_SRC scheme
;; element-of-set?は変更無し
(define  (element-of-set? x set)
  (cond ((null? set) #f)
        ((equal? x (car set)) #t)
        (else (element-of-set? x (cdr set)))))
;; adjoin-setはelement-of-set?を除去
(define (adjoin-set x set) (cons x set))
;; intersection-setは変更無し
(define (intersection-set set1 set2)
  (cond ((or (null? set1) (null? set2)) '())
        ((element-of-set? (car set1) set2)
         (cons (car set1) (intersection-set (cdr set1) set2)))
        (else (intersection-set (cdr set1) set2))))
;; union-setはelement-of-set?の判定ケースを除去
(define (union-set set1 set2)
  (cond ((null? set1) set2)
        (else (cons (car set1) (union-set (cdr set1) set2)))))
#+END_SRC

動作確認
#+BEGIN_SRC scheme
(element-of-set? 1 '()) ;; expected to #f
(element-of-set? 1 '(2 3)) ;; expected to #f
(element-of-set? 1 '(1)) ;; expected to #t
(element-of-set? 1 '(1 2 3)) ;; expected to #t

(adjoin-set 1 '()) ;; expected to (1)
(adjoin-set 1 '(2 3)) ;; expected to (1 2 3)
(adjoin-set 1 '(1 2 3)) ;; expected to (1 1 2 3)
(adjoin-set 2 '(1 2 3)) ;; expected to (2 1 2 3)

(intersection-set '() '()) ;; expected to ()
(intersection-set '(1 2) '(3 4 5)) ;; expected to ()
(intersection-set '(1 2) '(1 2 3 4)) ;; expected to (1 2)
(intersection-set '(1 2 1) '(1 2 3 4)) ;; expected to (1 2 1) これで正しい？

(union-set '() '()) ;; expected to ()
(union-set '(1) '(2)) ;; expected to (1 2)
(union-set '(1) '(2 3 4)) ;; expected to (1 2 3 4)
(union-set '(1 2) '(2 3 4)) ;; expected to (1 2 2 3 4)
(union-set '(1 2 1 3) '(2 3 4)) ;; expected to (1 2 1 3 2 3 4)
#+END_SRC

それぞれの効率
- element-of-set?
  - 変わらない。増加オーダーは \theta(n)
- adjoin-set
  - 効率は良くなる。増加オーダーは \theta(1)
- intersection-set
  - 変わらない。増加オーダーは \theta(n^2)
- union-set
  - 効率は良くなる。増加オーダーは \theta(n)

この表現が向いている応用
- ログ等の記録が主な目的の用途には向いている？

** 順序つきリストとしての集合

集合演算を早くする方法の一つとして、集合の要素が昇順に並ぶように表現を返るというものがある。

そのためには二つのオブジェクトを比較してどちらが大きいか判断するための方法が必要
- 記号を辞書順に比較したり
- オブジェクトに一意の数値を割り振ることに決めて対応する数値によって比較する、等

ここでは簡単のため、集合の要素が数値である場合についてのみ考える（>と<によって要素の比較が可能）

数値の集合表現は要素を昇順に並べたものを使う
- 前節では {1 3 6 10} を表すのに要素をどのように並べても良かったが、新
  しい表現では(1 3 6 10)というリストしか許可しない。

順序付けるメリット
- element-of-set?の探索処理を効率化でき、で要素を全て調べる必要がなくなる
- 探している項目よりも大きい要素に出会ったら、その項目が集合内に無いということがわかる

#+BEGIN_SRC scheme
(define (element-of-set? x set)
  (cond ((null? set) #f)
        ((= x (car set)) #t)
        ((< x (car set)) #f)
        (else (element-of-set? x (cdr set)))))
#+END_SRC

この場合の効率化
- 平均 \theta(n/2) => \theta(n) だけど一応効率化されている

intersection-setではさらに目覚ましい高速化が達成出来る
- 順序なしでは: \theta(n^2)
- 順序ありでは: \theta(n)
  - 必要なステップは最大でもset1とset2の大きさの合計（n+n=2n）なので \theta(n)

#+BEGIN_SRC scheme
(define (intersection-set set1 set2)
  (if (or (null? set1) (null? set2))
      '()
      (let ((x1 (car set1)) (x2 (car set2)))
        (cond ((= x1 x2)
               (cons x1 (intersection-set (cdr set1) (cdr set2))))
              ((< x1 x2)
               (intersection-set (cdr set1) set2))
              ((< x2 x1)
               (intersection-set set1 (cdr set2)))))))
#+END_SRC

** 練習問題
*** 練習問題 2.61 順序つき表現でのadjoin-setの実装

実装戦略
- xと(car set)を比較し、
  - x = (car set) なら、setを返す
  - x > (car set) なら、xと(cdr set) を再帰的に調べる
  - x < (car set) なら、それまでのsetにxを末尾に追加し、さらに(cdr set)をappendする(consでも大丈夫か)

回答
#+BEGIN_SRC scheme
;; original adjoin-set
(define (adjoin-set x set)
  (if (element-of-set? x set)
      set
      (cons x set)))

;;==== 回答 =====
(define (adjoin-set x set)
  (define (iter lower rest)
    (cond ((null? rest) (append lower (list x)))
          ((= x (car rest)) set)
          ((< x (car rest)) (append lower (list x) rest))
          (else (iter (append lower (list (car rest)))
                      (cdr rest)))))
  (iter '() set))

;;==== 時田さん回答 こちらの方が無駄がない =====
(define (adjoin-set x set)
  (cond ((null? set) (cons x set))
        ((= x (car set)) set)
        ((< x (car set)) (cons x set))
        (else (cons (car set) (adjoin-set x (cdr set))))
    )
)

#+END_SRC

動作確認
#+BEGIN_SRC scheme
(adjoin-set 1 '()) ;; expected to (1)
(adjoin-set 1 '(2 4 5)) ;; expected to (1 2 4 5)
(adjoin-set 2 '(2 4 5)) ;; expected to (2 4 5)
(adjoin-set 3 '(2 4 5)) ;; expected to (2 3 4 5)
#+END_SRC

増加オーダーの考察
- 最速で初回で見つかる。最悪setの最後の要素まで見るので平均 \theta(1/2N)

*** 練習問題 2.62 順序つきリストに対するunion-set実装

回答
#+BEGIN_SRC scheme
;; original union-set
(define (union-set set1 set2)
  (cond ((null? set1) set2)
        ((element-of-set? (car set1) set2)
         (union-set (cdr set1) set2))
        (else (cons (car set1) (union-set (cdr set1) set2)))))

;;==== 回答 ====
(define (union-set set1 set2)
  (cond ((null? set1) set2)
        ((null? set2) set1)
        (else
          (if (null? set1)
              set2
              (let ((x1 (car set1)) (x2 (car set2)))
                (cond ((= x1 x2)
                       (cons x1 (union-set (cdr set1) (cdr set2))))
                      ((< x1 x2)
                       (cons x1 (union-set (cdr set1) set2)))
                      ((> x1 x2)
                       (cons x2 (union-set set1 (cdr set2))))))))))
#+END_SRC

動作確認
#+BEGIN_SRC scheme
(union-set '() '()) ;; expected to ()
(union-set '(1) '(2)) ;; expected to (1 2)
(union-set '(1) '(2 3 4)) ;; expected to (1 2 3 4)
(union-set '(1 2) '(2 3 4)) ;; expected to (1 2 3 4)
(union-set '(2 4 6) '(1 3 5)) ;; expected to (1 2 3 4 5 6)
#+END_SRC

** 二分木としての集合

集合の要素を木という形式で配置すれば順序つきリスト表現をさらに改善できる
- 木の各ノードは集合の要素を一つ持つ（それをノードの”エントリ”と呼ぶ）
- 他の二つのノードへのリンクも持っている
  - 左のリンクは、そのノードより小さな要素を指している
  - 右のリンクは、そのノードより大きな要素を指している

*木による表現の利点（木の効率性の話し）*

ある数値xがある集合に含まれているかチェックする場合:
- まずxとトップノードのエントリを比較する
  - もしxがそれより小さければ左部分木だけを探索すれば良い
  - もしxがそれより大きければ右部分木だけを探索すれば良い

もし木が *バランスが取れた* 状態であれば、各部分木の大きさは元の木の約
半分になる。つまり一回のステップで大きさnの木を探索するという問題を、
大きさn/2の木を探索するという問題に縮小したことになる。

つまり、大きさnの木の探索に必要なステップ数は \theta(log n) で増加すると予想できる。


木はリストを使って表現出来る。
- 各ノードは、ノードのエントリ、左部分木、右部分木の三つの項目のリストとなる
#+BEGIN_SRC scheme
(define (entry tree) (car tree))                              ;; selector
(define (left-branch tree) (cadr tree))                       ;; selector
(define (right-branch tree) (caddr tree))                     ;; selector
(define (make-tree entry left right) (list entry left right)) ;; constructor
#+END_SRC

木を使ったelement-of-set?実装
#+BEGIN_SRC scheme
(define (element-of-set? x set)
  (cond ((null? set) #f)
        ((= x (entry set)) #t)
        ((< x (entry set)) (element-of-set? x (left-branch tree)))
        ((> x (entry set)) (element-of-set? x (right-branch tree)))))
#+END_SRC

集合に項目を追加する操作も同様に実装でき、必要ステップ数は \theta(\log n) になる
#+BEGIN_SRC scheme
(define (adjoin-set x set)
  (cond ((null? set) (make-tree x '() '()))
        ((= x (entry set)) set)
        ((< x (entry set)) (make-tree (entry set)
                                      (adjoin-set x (left-branch set))
                                      (right-branch set)))
        ((> x (entry set)) (make-tree (entry set)
                                      (left-branch set)
                                      (adjoin-set x (right-branch set))))))
#+END_SRC

*** データ抽象化の観点での整理
注釈39にあるデータ抽象化での整理
- 集合は集合演算（手続き）により木表現を抽象化する
  - *union-set*
  - *intersection-set*
  - *element-of-set?*
  - *adjoin-set*
- 木は、ノードの演算（手続き）によりリスト表現を抽象化する
  - *entry*
  - *left-branch*
  - *right-branch*
  - *make-tree*

** 練習問題
*** 練習問題 2.63 tree->listの解析

tree->list実装
#+BEGIN_SRC scheme
(define (tree->list-1 tree)
  (if (null? tree)
      '()
      (append (tree->list-1 (left-branch tree))
              (cons (entry tree)
                    (tree->list-1 (right-branch tree))))))

(define (tree->list-2 tree)
  (define (copy-to-list tree result-list)
    (if (null? tree)
        result-list
        (copy-to-list (left-branch tree)
                      (cons (entry tree)
                            (copy-to-list (right-branch tree) result-list)))))
  (copy-to-list tree '()))
#+END_SRC

- a.) 二つの手続きは全ての木に対して同じ結果を生むか？

#+BEGIN_SRC scheme
;; test data
(define tree '())
(define fig2.16a
  (adjoin-set 11
   (adjoin-set 9
    (adjoin-set 5
     (adjoin-set 1
      (adjoin-set 3
       (adjoin-set 7 tree)))))))
(define fig2.16b
  (adjoin-set 11
   (adjoin-set 9
    (adjoin-set 5
     (adjoin-set 7
      (adjoin-set 1
       (adjoin-set 3 tree)))))))
(define fig2.16c
  (adjoin-set 11
   (adjoin-set 7
    (adjoin-set 9
     (adjoin-set 1
      (adjoin-set 3
       (adjoin-set 5 tree)))))))
(define fig2.17
  (adjoin-set 11
   (adjoin-set 9
    (adjoin-set 7
     (adjoin-set 5
      (adjoin-set 3
       (adjoin-set 1 tree)))))))

;; 動作確認
(tree->list-1 fig2.16a)
> (1 3 5 7 9 11)
(tree->list-1 fig2.16b)
> (1 3 5 7 9 11)
(tree->list-1 fig2.16c)
> (1 3 5 7 9 11)
(tree->list-1 fig2.17)
> (1 3 5 7 9 11)

(tree->list-2 fig2.16a)
> (1 3 5 7 9 11)
(tree->list-2 fig2.16b)
> (1 3 5 7 9 11)
(tree->list-2 fig2.16c)
> (1 3 5 7 9 11)
(tree->list-2 fig2.17)
> (1 3 5 7 9 11)
#+END_SRC

上記動作結果より、二つの手続きは全ての木に対して同じ結果を生成すると考えられる。

- b.) 増加オーダーのステップ数の考察

**** Current

ステップ数を数えてみる。
#+BEGIN_SRC scheme
;; カウント情報の追加
(define (tree->list-1 tree)
  (display "1 ")
  (if (null? tree)
      '()
      (append (tree->list-1 (left-branch tree))
              (cons (entry tree)
                    (tree->list-1 (right-branch tree))))))

(define (tree->list-2 tree)
  (define (copy-to-list tree result-list)
    (display "1 ")
    (if (null? tree)
        result-list
        (copy-to-list (left-branch tree)
                      (cons (entry tree)
                            (copy-to-list (right-branch tree) result-list)))))
  (copy-to-list tree '()))

;; 補助手続き
(define (seq n)
  (define (iter m res)
    (if (> m n)
        res
        (iter (+ m 1) (append res (list m)))))
  (iter 1 '()))

;; list->tree from exer. 2.64
(define (list->tree elements)
  (car (partial-tree elements (length elements))))
(define (partial-tree elts n)
  (if (= n 0)
      (cons '() elts)
      (let ((left-size (quotient (- n 1) 2)))
        (let ((left-result (partial-tree elts left-size)))
          (let ((left-tree (car left-result))
                (non-left-elts (cdr left-result))
                (right-size (- n (+ left-size 1))))
            (let ((this-entry (car non-left-elts))
                  (right-result (partial-tree (cdr non-left-elts) right-size)))
              (let ((right-tree (car right-result))
                    (remaining-elts (cdr right-result)))
                (cons (make-tree this-entry
                                 left-tree
                                 right-tree)
                      remaining-elts))))))))
#+END_SRC

ステップ数のカウント（練習問題 2.64のlist->treeを使って検証）
- tree->list-1
  #+BEGIN_SRC scheme
  (tree->list-1 (list->tree (seq 1)))  
  (+ 1 1 1)
  3

  (tree->list-1 (list->tree (seq 4)))  
  (+ 1 1 1 1 1 1 1 1 1)
  9

  (tree->list-1 (list->tree (seq 8)))  
  (+ 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1)
  17

  (tree->list-1 (list->tree (seq 16))) 
  (+ 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1)
  33

  (tree->list-1 (list->tree (seq 32))) 
  (+ 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1)
  65
  #+END_SRC
- tree->list-2
  #+BEGIN_SRC scheme
  (tree->list-2 (list->tree (seq 1)))  ;; 1 1 1
  (+ 1 1 1)
  3

  (tree->list-2 (list->tree (seq 4)))  ;; 1 1 1 1 1 1 1 1 1
  (+ 1 1 1 1 1 1 1 1 1)
  9

  (tree->list-2 (list->tree (seq 8)))  ;; 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 
  (+ 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1)
  17

  (tree->list-2 (list->tree (seq 16))) ;; 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
  (+ 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1)
  33

  (tree->list-2 (list->tree (seq 32))) ;; 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
  (+ 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1)
  65
  #+END_SRC

以上より、tree->list-1, tree-list-2ともにステップ数は 2N + 1 なので、増加オーダーは \theta(N) である。


**** OLD (Deprecated)

  - tree->list-1、tree-list2ともにあるエントリの左部分木を取り出し、そ
    の結果と、当該エントリと右部分木のペアを連結していくという挙動になっ
    ている
  - これは結局木構造の各ノードの数 + リーフノードの子（空リスト）数分
    だけ再帰的に実行される。式で表すと、ステップ数をSとすると
    #+BEGIN_SRC latex
    \[
        S = N + (N + 1) = 2N + 1
    \]
    #+END_SRC
  - 従って、増加オーダーは、 \theta(N) となる

#+BEGIN_SRC scheme
(define test1
  (lambda (set)
    (define (tree->list-1 tree)
      (display "1 ")
      (if (null? tree)
          '()
          (append (tree->list-1 (left-branch tree))
                  (cons (entry tree)
                        (tree->list-1 (right-branch tree))))))
    (tree->list-1 set)))

(define test2
  (lambda (set)
    (define (tree->list-2 tree)
      (define (copy-to-list tree result-list)
        (display "1 ")
        (if (null? tree)
            result-list
            (copy-to-list (left-branch tree)
                          (cons (entry tree)
                                (copy-to-list (right-branch tree) result-list)))))
      (copy-to-list tree '()))
    (tree->list-2 set)))

;; # of tree->list-1 calls
(test1 fig2.16a)
1 1 1 1 1 1 1 1 1 1 1 1 1 (1 3 5 7 9 11)
(test1 fig2.16b)
1 1 1 1 1 1 1 1 1 1 1 1 1 (1 3 5 7 9 11)
(test1 fig2.16c)
1 1 1 1 1 1 1 1 1 1 1 1 1 (1 3 5 7 9 11)
(test1 fig2.17)
1 1 1 1 1 1 1 1 1 1 1 1 1 (1 3 5 7 9 11)

;; # of tree->list-2 calls
(test2 fig2.16a)
1 1 1 1 1 1 1 1 1 1 1 1 1 (1 3 5 7 9 11)
(test2 fig2.16b)
1 1 1 1 1 1 1 1 1 1 1 1 1 (1 3 5 7 9 11)
(test2 fig2.16c)
1 1 1 1 1 1 1 1 1 1 1 1 1 (1 3 5 7 9 11)
(test2 fig2.17)
1 1 1 1 1 1 1 1 1 1 1 1 1 (1 3 5 7 9 11)
#+END_SRC

上記結果より、バランスの取れた木を変換する際に同じステップ数の増加オーダーを持っているといえる。
tree->list-1は再帰プロセスで、tree->list-2は反復プロセスなので

呼び出し回数だけだと動きを把握しづらいので内容も出力してみる
#+BEGIN_SRC scheme
(define (tree->list-1 tree)
  (display tree) (newline)
  (if (null? tree)
      '()
      (append (tree->list-1 (left-branch tree))
              (cons (entry tree)
                    (tree->list-1 (right-branch tree))))))
(define (tree->list-2 tree)
  (define (copy-to-list tree result-list)
    (display tree) (display " ") (display result-list) (newline) 
    (if (null? tree)
        result-list
        (copy-to-list (left-branch tree)
                      (cons (entry tree)
                            (copy-to-list (right-branch tree) result-list)))))
  (copy-to-list tree '()))


;; test code
(tree->list-1 fig2.16a)
(tree->list-1 fig2.16b)
(tree->list-1 fig2.16c)
(tree->list-1 fig2.17)

(tree->list-2 fig2.16a)
(tree->list-2 fig2.16b)
(tree->list-2 fig2.16c)
(tree->list-2 fig2.17)
#+END_SRC

出力結果: tree-list-1
#+BEGIN_SRC 
gosh> (tree->list-1 fig2.16a)
(7 (3 (1 () ()) (5 () ())) (9 () (11 () ())))
(3 (1 () ()) (5 () ()))
(1 () ())
()
()
(5 () ())
()
()
(9 () (11 () ()))
()
(11 () ())
()
()
(1 3 5 7 9 11)

gosh> (tree->list-1 fig2.16b)
(3 (1 () ()) (7 (5 () ()) (9 () (11 () ()))))
(1 () ())
()
()
(7 (5 () ()) (9 () (11 () ())))
(5 () ())
()
()
(9 () (11 () ()))
()
(11 () ())
()
()
(1 3 5 7 9 11)

gosh> (tree->list-1 fig2.16c)
(5 (3 (1 () ()) ()) (9 (7 () ()) (11 () ())))
(3 (1 () ()) ())
(1 () ())
()
()
()
(9 (7 () ()) (11 () ()))
(7 () ())
()
()
(11 () ())
()
()
(1 3 5 7 9 11)

gosh> (tree->list-1 fig2.17)
(1 () (3 () (5 () (7 () (9 () (11 () ()))))))
()
(3 () (5 () (7 () (9 () (11 () ())))))
()
(5 () (7 () (9 () (11 () ()))))
()
(7 () (9 () (11 () ())))
()
(9 () (11 () ()))
()
(11 () ())
()
()
(1 3 5 7 9 11)
#+END_SRC

出力結果: tree-list-2
#+BEGIN_SRC
gosh> (tree->list-2 fig2.16a)
(7 (3 (1 () ()) (5 () ())) (9 () (11 () ()))) ()
(9 () (11 () ())) ()
(11 () ()) ()
() ()
() (11)
() (9 11)
(3 (1 () ()) (5 () ())) (7 9 11)
(5 () ()) (7 9 11)
() (7 9 11)
() (5 7 9 11)
(1 () ()) (3 5 7 9 11)
() (3 5 7 9 11)
() (1 3 5 7 9 11)
(1 3 5 7 9 11)

gosh> (tree->list-2 fig2.16b)
(3 (1 () ()) (7 (5 () ()) (9 () (11 () ())))) ()
(7 (5 () ()) (9 () (11 () ()))) ()
(9 () (11 () ())) ()
(11 () ()) ()
() ()
() (11)
() (9 11)
(5 () ()) (7 9 11)
() (7 9 11)
() (5 7 9 11)
(1 () ()) (3 5 7 9 11)
() (3 5 7 9 11)
() (1 3 5 7 9 11)
(1 3 5 7 9 11)

gosh> (tree->list-2 fig2.16c)
(5 (3 (1 () ()) ()) (9 (7 () ()) (11 () ()))) ()
(9 (7 () ()) (11 () ())) ()
(11 () ()) ()
() ()
() (11)
(7 () ()) (9 11)
() (9 11)
() (7 9 11)
(3 (1 () ()) ()) (5 7 9 11)
() (5 7 9 11)
(1 () ()) (3 5 7 9 11)
() (3 5 7 9 11)
() (1 3 5 7 9 11)
(1 3 5 7 9 11)

gosh> (tree->list-2 fig2.17)
(1 () (3 () (5 () (7 () (9 () (11 () ())))))) ()
(3 () (5 () (7 () (9 () (11 () ()))))) ()
(5 () (7 () (9 () (11 () ())))) ()
(7 () (9 () (11 () ()))) ()
(9 () (11 () ())) ()
(11 () ()) ()
() ()
() (11)
() (9 11)
() (7 9 11)
() (5 7 9 11)
() (3 5 7 9 11)
() (1 3 5 7 9 11)
(1 3 5 7 9 11)
#+END_SRC

備考
#+BEGIN_SRC scheme
;; テストデータ作成時にaccumulate (fold-right)使おうとしたけど結局fold-leftも使えなそうだった件

;; 直感的。rootエントリは1
;; ただしこれはfold-leftともちょっと違う
;; fold-leftだと一番右の演算は(adjoin-set tree 1) となるはずで、これはadjoin-setではエラーとなる。
(adjoin-set 11 (adjoin-set 9 (adjoin-set 7 (adjoin-set 5 (adjoin-set 3 (adjoin-set 1 tree))))))
> (1 () (3 () (5 () (7 () (9 () (11 () ()))))))

;; 反直感的。rootエントリが11になっている。
;; fold-rightだと列の最初の項目は一番最後に演算されるので、今回は意図した通りの動きではない
(accumulate adjoin-set '() '(1 3 5 7 9 11))
> (11 (9 (7 (5 (3 (1 () ()) ()) ()) ()) ()) ()) 
#+END_SRC

*** 練習問題 2.64 バランス木

list->treeとpartial-tree
#+BEGIN_SRC scheme
(define (list->tree elements)
  (car (partial-tree elements (length elements))))
(define (partial-tree elts n)
  (if (= n 0)
      (cons '() elts)
      (let ((left-size (quotient (- n 1) 2)))
        (let ((left-result (partial-tree elts left-size)))
          (let ((left-tree (car left-result))
                (non-left-elts (cdr left-result))
                (right-size (- n (+ left-size 1))))
            (let ((this-entry (car non-left-elts))
                  (right-result (partial-tree (cdr non-left-elts) right-size)))
              (let ((right-tree (car right-result))
                    (remaining-elts (cdr right-result)))
                (cons (make-tree this-entry
                                 left-tree
                                 right-tree)
                      remaining-elts))))))))
#+END_SRC

**** a. partial-treeの挙動の説明と(1 3 5 7 9 11)で生成される木を描く

***** 挙動の説明

- 挙動メモ
  - left-sizeには $(n-1)/2$ （partial-treeの要素数 - 1の半分（の商、つまり整数部分）） がセットされる
  - left-size数だけpartial-treeを作り、それをleft-resultに格納する。こ
    れはつまり、リストの先頭から (n-1)/2 要素まででpartial-treeを作る
    ということ。さらにこのときpartial-treeを再帰的に呼び出しているので、
    リストの左半分を部分リストに作り変えるということを再帰的におこなっ
    ている。
    #+BEGIN_SRC scheme
    (let ((left-result (partial-tree elts left-size))))
    #+END_SRC
  - 次に、left-result（これは構築された部分木とそこに含まれなかった要
    素のリストのペア）を使って、left-tree, non-leaf-elts, right-sizeと
    いう局所変数を定義する。
    - left-tree: 左部分木
    - non-left-elts: 左部分木以外の要素のリスト
    - right-size: n - (left-size) + 1 => ここで +1 しているのは、この
      後でリストの中央の要素を取り出して使いたいから
  - 次に、上記局所変数を使って、this-entry, right-resultという局所変数
    を定義する
    - this-entry: 部分木でない要素リストの先頭要素（つまりリストの中央の要素）
    - right-result: this-entryを除いた左部分木でない要素リストから
      right-size数だけ部分木を作成した結果。partial-treeを呼ぶのでペアで受け取る
      #+BEGIN_SRC scheme
      (let ((rignth-result (partial-tree (cdr non-left-elts) right-size))))
      #+END_SRC
  - 次に、right-resultを使って、right-tree, remaining-eltsという局所変
    数を定義する
    - right-tree: this-entryに対する右部分木
    - remaining-elts: right-treeに入らなかった余りの要素リスト
  - 最後にconsでthis-entryをエントリとしたノードを作成する。このとき
    consの最後の要素にはremaining-eltsを含めている。これは部分木からみ
    ると親ノードの右部分木に相当する要素のリストになる。もし着目してい
    る要素がルートの場合、remaining-eltsは空リストになるはず。
    #+BEGIN_SRC scheme
    (cons (make-tree this-entry left-tree right-tree) remaining-elts)
    #+END_SRC

- 挙動まとめ
  - partial-treeは与えられたリストについて、中央の要素（エントリ）を基
    準にしてそれよりも先頭側を左部分木、末尾側を右部分木となるように
    partial-treeを再帰的に呼び出す。そして左部分木と右部分木とエントリ
    を使ってノードを作成（make-tree）し、当該ノードとそのノードの左右
    部分木に含まれなかった（親ノードから見て右部分木に当たる）要素のリ
    ストをconsして返す
    - ルートノードを処理するときは、（親ノードは存在しないので）
      remaining-eltsは空リストになる
  - partial-treeは左右の部分木毎にその中央要素を起点にリストを生成する
    のでバランスの取れた木を生成することが可能である

***** (1 3 5 7 9 11)に対するlist->treeが生成する木の描画

  - 実行結果
    #+BEGIN_SRC scheme
    > (list->tree '(1 3 5 7 9 11))
    (5 (1 () (3 () ())) (9 (7 () ()) (11 () ())))
    #+END_SRC
  - 生成された木
    [[./img/sicp_2-3-3_ex2-64_a.png]]

**** b. n要素リストの変換に必要なステップ数の増加オーダー
- ノート参照
- 結論としてはこちらも \theta(N) と予想される。

*増加オーダーの検証 (TBD)*
- n要素の順序つきリストを二分木に変換するステップ数を確認する
#+BEGIN_SRC scheme
(define (list->tree elements)
  (car (partial-tree elements (length elements))))
(define (partial-tree elts n)
  (display "1 ")
  (if (= n 0)
      (cons '() elts)
      (let ((left-size (quotient (- n 1) 2)))
        (let ((left-result (partial-tree elts left-size)))
          (let ((left-tree (car left-result))
                (non-left-elts (cdr left-result))
                (right-size (- n (+ left-size 1))))
            (let ((this-entry (car non-left-elts))
                  (right-result (partial-tree (cdr non-left-elts) right-size)))
              (let ((right-tree (car right-result))
                    (remaining-elts (cdr right-result)))
                (cons (make-tree this-entry
                                 left-tree
                                 right-tree)
                      remaining-elts))))))))

;; List Generator
(define (seq n)
  (define (iter m res)
    (if (> m n)
        res
        (iter (+ m 1) (append res (list m)))))
  (iter 1 '()))


(list->tree (seq 1))  ;; 1 1 1
(+ 1 1 1)
> 3
(list->tree (seq 2))  ;; 1 1 1 1 1
(+ 1 1 1 1 1)
> 5
(list->tree (seq 4))  ;; 1 1 1 1 1 1 1 1 1
(+ 1 1 1 1 1 1 1 1 1)
> 9
(list->tree (seq 8))  ;; 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
(+ 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1)
> 17
(list->tree (seq 16)) ;; 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
(+ 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1)
> 33
(list->tree (seq 32)) ;; 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
(+ 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1)
> 65
(list->tree (seq 64)) ;; 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
(+ 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1)
> 129
#+END_SRC

これより、ステップ数は 2N + 1 になるので、増加オーダーは \theta(N)

*** 練習問題 2.65 \theta(n) での union-setとintersection-setの実装

増加オーダーのまとめ
- tree <=> list 変換手続き
  | procedure    | complexity |
  |--------------+------------|
  | tree->list-1 | \theta(n)  |
  | tree->list-2 | \theta(n)  |
  | list->tree   | \theta(n)  |

- 集合演算
  | procedure        | complexity (not ordered) | complexity (ordered) | complexity (balanced tree) | note                |
  |------------------+--------------------------+----------------------+----------------------------+---------------------|
  | union-set        | \theta(n^2)              | \theta(n)            |                            | exercise 2.59, 2.62 |
  | intersection-set | \theta(n^2)              | \theta(n)            |                            |                     |
  | element-of-set?  | \theta(n)                | \theta(n)            | \theta(\log n)             |                     |
  | adjoin-set       | \theta(n)                | \theta(n)            | \theta(\log n)             | exercise 2.61       |


上記より、 \theta(n) のunion-setとintersection-setを実装する方針は以下のようになる。
- バランスした二分木tree1, tree2を順序付きリストに変換する
  (tree->list-1 or tree->list-2)。ステップ数は n + m (m = αnとすれば、
  n + m = n + αn = (1 + α)n)なので、増加オーダーは \theta(n)
- 順序付きリストset1, set2を使って union-set(intersection-set)を実行する。増加オーダーは \theta(n)
- 順序付きリストをlist->treeを使ってバランスした二分木に戻す。増加オーダーは \theta(n)

上記三つフェーズのそれぞれは \theta(n) であり、全体としてのステップ数
は各フェーズのステップ数の和になるので全体としての増加オーダーも
\theta(n) となる

回答
#+BEGIN_SRC scheme
(define (union-set-internal set1 set2)
  (cond ((null? set1) set2)
        ((null? set2) set1)
        (else
          (if (null? set1)
              set2
              (let ((x1 (car set1)) (x2 (car set2)))
                (cond ((= x1 x2)
                       (cons x1 (union-set-internal (cdr set1) (cdr set2))))
                      ((< x1 x2)
                       (cons x1 (union-set-internal (cdr set1) set2)))
                      ((> x1 x2)
                       (cons x2 (union-set-internal set1 (cdr set2))))))))))

(define (intersection-set-internal set1 set2)
  (if (or (null? set1) (null? set2))
      '()
      (let ((x1 (car set1)) (x2 (car set2)))
        (cond ((= x1 x2)
               (cons x1 (intersection-set-internal (cdr set1) (cdr set2))))
              ((< x1 x2)
               (intersection-set-internal (cdr set1) set2))
              ((< x2 x1)
               (intersection-set-internal set1 (cdr set2)))))))

(define (union-set set1 set2)
  (let ((list1 (tree->list-1 set1))
        (list2 (tree->list-2 set2)))
    (list->tree (union-set-internal list1 list2))))

(define (intersection-set set1 set2)
  (let ((list1 (tree->list-1 set1))
        (list2 (tree->list-2 set2)))
    (list->tree (intersection-set-internal list1 list2))))
#+END_SRC

動作確認
#+BEGIN_SRC scheme
(union-set
 (list->tree '(1 2 3))
 (list->tree '(1 2 3))) ;; (2 (1 () ()) (3 () ()))
(union-set
 (list->tree '(1 3 5))
 (list->tree '(2 4 6))) ;; (3 (1 () (2 () ())) (5 (4 () ()) (6 () ())))

(intersection-set
 (list->tree '(1 2 3))
 (list->tree '(1 2 3))) ;; (2 (1 () ()) (3 () ()))
(intersection-set
 (list->tree '(1 3 5))
 (list->tree '(2 4 6))) ;; ()
(intersection-set
 (list->tree '(1 3 5 7 8 9 10))
 (list->tree '(2 4 6 7 8 10))) ;; (8 (7 () ()) (10 () ()))
#+END_SRC

*最終的な増加オーダーのまとめ*
- tree <=> list 変換手続き
  | procedure    | complexity |
  |--------------+------------|
  | tree->list-1 | \theta(n)  |
  | tree->list-2 | \theta(n)  |
  | list->tree   | \theta(n)  |

- 集合演算
  | procedure        | complexity (not ordered) | complexity (ordered) | complexity (balanced tree) | note                      |
  |------------------+--------------------------+----------------------+----------------------------+---------------------------|
  | union-set        | \theta(n^2)              | \theta(n)            | \theta(n)                  | exercise 2.59, 2.62, 2.65 |
  | intersection-set | \theta(n^2)              | \theta(n)            | \theta(n)                  | exercise 2.65             |
  | element-of-set?  | \theta(n)                | \theta(n)            | \theta(\log n)             |                           |
  | adjoin-set       | \theta(n)                | \theta(n)            | \theta(\log n)             | exercise 2.61             |


** 集合と情報検索

ここまでは
- 集合をリストで表現するのにどのような方法があるかを検討した。
- データオブジェクトに対してどのような表現を選ぶかということが、パフォーマンスに大きな影響を及ぼすことをみた。

集合に対して詳しく検討するもう一つの理由
- 情報検索に関わる応用の中でよく出てくるものだから

以下では個別のレコードを大量に含むデータベースについて考える。
- 企業の人事ファイルや会計システムの取引など
- データ管理システムではレコードにアクセスする効率的な手法が必要となる
  - 各レードの中で識別 *キー(key)* として使える部分を特定することによって行える
  - 例) 従業員番号、取引番号等（レコードが一意に特定できれば何でも良い）
- レコードをデータ構造として定義する際は、レコードに関連付けられたキーを取得する =key= セレクタ手続きを持たせる
ここではデータベースをレコードの集合として表現する

あるキーに対するレコードの場所を調べるには =lookup= という手続きを使う。
- キーとデータベースを引数にとり、そのキーを持つレコードを返すか、レコードがなければ偽(#f)を返す
- lookupは =element-of-set?= とほぼ同じように実装される

レコードの集合が順序なしリストとして表現されている場合のlookup実装
#+BEGIN_SRC scheme
(define (lookup given-key set-of-records)
  (cond ((null? set-of-records) #f)
        ((equal? given-key (key (car set-of-records))) (car set-of-records))
        (else (lookup given-key (cdr set-of-records)))))
#+END_SRC

=コメント=
- 最悪全てのレコードをスキャンするのでステップ数の増加オーダーは \theta(n)

レコードを”ランダムアクセス”する必要がある情報検索システムでは、普通は木構造による手法によって表現される。（例えば二分木等）

システムを設計するにあたってはデータ抽象化の方法論はとても役に立つ
- 設計者は順序なしリストのような単純で素直な表現で最初の実装を作り(*quick and dirty*)、システムの残りの部分のテストしやすくする
- データ表現を修正してより洗練されたものにすることは後になってからでもできる

もしデータベースが抽象セレクタとコンストラクタによってアクセスされるようになっていれば、上記のように表現を変更しても、システムの残りの部分には修正の必要がないはず。

** 練習問題
*** 練習問題 2.66 二分木で表現されたレコード集合に対するlookup実装

実装計画
- 最初にset-of-recordsがnullかチェックし、nullだったらfalseを返す
- 次に、given-keyとsetの先頭要素のkeyを比較する
  - 一致: その要素を返す
  - given-key < (key entry): (left-branch set)についてlookupを再帰呼び出し
  - given-key > (key entry): (right-branch set)についてlookupを再帰呼び出し

回答
#+BEGIN_SRC scheme
(define (lookup given-key set-of-records)
  (if (null? set-of-records)
      #f
      (cond ((equal? given-key (key (car set-of-records))) (car set-of-records))
            ((< given-key (key (car set-of-records))) (lookup given-key (left-branch set-of-records)))
            (else (lookup given-key (right-branch set-of-records))))))
#+END_SRC

動作確認
#+BEGIN_SRC scheme
;; 二分木のインターフェースにkeyを取得する手続きを追加する
(define (entry tree) (car tree))                              ;; selector
(define (left-branch tree) (cadr tree))                       ;; selector
(define (right-branch tree) (caddr tree))                     ;; selector
(define (make-tree entry left right) (list entry left right)) ;; constructor
;; 簡単のため、keyはentryそのものとする
(define (key tree)
  (if (pair? tree)
      (entry tree)
      tree))

;; insert
(define db (list->tree '(1 2 3 4 5 6 7 8 9 10)))

;; lookup tests
(lookup 1 db)
(lookup 5 db)
(lookup 10 db)
(lookup 11 db)
#+END_SRC

* 2.3.4 例: ハフマン符号化木

この節では集合と木を操作するためのリスト構造とデータ抽象化の使い方を練習する。
ここではデータを1と0の列（ビット列）として表現する手法を適用対象とする
- n個の異なる記号を区別しようとすると、記号毎に $\log2 n$ ビットを使う必要がある
- 例) A,B,C,D,E,F,G,H の8個の記号を使う場合、1文字あたり3ビットの符号を選べる
  #+BEGIN_SRC 
  A 000  C 010  E 100  G 110
  B 001  D 011  F 101  H 111
  #+END_SRC
  - この符号を使って =BACADAEAFABBAAAGAH= を符号化すると、以下のように54ビットの列になる
    #+BEGIN_SRC 
    001000010000011000100000101000001001000000000110000111
    #+END_SRC

** ハフマン木の生成

- TBD

** ハフマン木の表現

木の表現方法
- 木の葉
  - =leaf= という記号、その葉の記号、重み、からなるリストで表現する
  #+BEGIN_SRC scheme
  (define (make-leaf symbol weight) (list 'leaf symbol weight))
  (define (leaf? object) (eq? (car object) 'leaf))
  (define (symbol-leaf x) (cadr x))
  (define (weight-leaf x) (caddr x))
  #+END_SRC

- 一般の木
  - 左枝、右枝、記号の集合、重み、からなる
  - 記号の集合: 単純な記号のリスト(appendして和集合を作成)
  - 木の重み: 二つのノードの重みの合計
  #+BEGIN_SRC scheme
  ;; コンストラクタ
  (define (make-code-tree left right)
    (list left
          right
          (append (symbols left) (symbols right)) ;; 記号の集合
          (+ (weight left) (weight right))))      ;; 重み（左枝、右枝の重みの合計）

  ;; セレクタ
  (define (left-branch tree) (car tree))
  (define (right-branch tree) (cadr tree))
  (define (symbols tree)
    (if (leaf? tree)
        (list (symbol-leaf tree))
        (caddr tree)))
  (define (weight tree)
    (if (leaf? tree)
        (weight-leaf tree)
        (cadddr tree)))
  #+END_SRC

- 手続きsymbolsとweightは渡されたものが葉である場合と一般の木である場合とで処理を分ける必要がある。
  - これらは、 *ジェネリック手続き (generic procedure)* （二種類以上のデータを扱う手続き）の簡単な例となっている

** 復号化手続き

以下は復号化アルゴリズムを実装したもの。0と1のリストに加え、ハフマン木を引数にとる。
- *decode-1* 手続き
  - 残りのビットのリストと、木の中での現在位置、という二つの引数をとる
  - リストの次のビットが0か1かによって左か右の枝を”降りて”いく（ =choose-branch= 手続きで行っている）
  - 葉に辿り着くと、木の根から始めてメッセージの残りを複合した結果に葉の記号をconsすることで、メッセージの次の記号として返す
- *choose-branch* 手続き
  - リストの次のビットが0か1かによって左か右の枝を”降りて”いく
  - 入力データ中に0か1以外のものを見つけたらエラーを出す

#+BEGIN_SRC scheme
(define (decode bits tree)
  (define (decode-1 bits current-branch)
    (if (null? bits)
        '()
        (let ((next-branch (choose-branch (car bits) current-branch)))
          (if (leaf? next-branch)
              (cons (symbol-leaf next-branch)
                    (decode-1 (cdr bits) tree))
              (decode-1 (cdr bits) next-branch)))))
  (decode-1 bits tree))

(define (choose-branch bit branch)
  (cond ((= bit 0) (left-branch branch))
        ((= bit 1) (right-branch branch))
        (else (error "bad bit: CHOOSE-BRANCH" bit))))
#+END_SRC

** 重み付き要素の集合

- 木の生成アルゴリズムでは集合の最小項目を何度も求めることになるので、順序付きの表現を使うほうが便利
- 葉と木の集合は、重みの昇順に配置した要素のリストとして表現する

以下は集合を構築するための手続き
#+BEGIN_SRC scheme
(define (adjoin-set x set)
  (cond ((null? set) (list x))
        ((< (weight x) (weight (car set))) (cons x set))
        (else (cons (car set)
                    (adjoin-set x (cdr set))))))
#+END_SRC

以下は =((A 4) (B 2) (C 1) (D 1))= のような記号と頻度のペアのリストを取り、初期状態での葉の順序付き集合を構築し、ハフマンアルゴリズムに従ってすぐ連結できるようにする手続き
#+BEGIN_SRC scheme
(define (make-leaf-set pairs)
  (if (null? pairs)
      '()
      (let ((pair (car pairs)))
        (adjoin-set (make-leaf (car pair)    ;; symbol
                               (cadr pair))  ;; frequency
                    (make-leaf-set (cdr pairs))))))
#+END_SRC

** 練習問題

事前準備
#+BEGIN_SRC scheme
;;; leaf procedures ;;;
(define (make-leaf symbol weight) (list 'leaf symbol weight))
(define (leaf? object) (eq? (car object) 'leaf))
(define (symbol-leaf x) (cadr x))
(define (weight-leaf x) (caddr x))

;;; general tree procedures ;;;
;; constructor
(define (make-code-tree left right)
  (list left
        right
        (append (symbols left) (symbols right)) ;; 記号の集合
        (+ (weight left) (weight right))))      ;; 重み（左枝、右枝の重みの合計）
;; selector
(define (left-branch tree) (car tree))
(define (right-branch tree) (cadr tree))
(define (symbols tree)
  (if (leaf? tree)
      (list (symbol-leaf tree))
      (caddr tree)))
(define (weight tree)
  (if (leaf? tree)
      (weight-leaf tree)
      (cadddr tree)))


;;; decode procedures ;;;
(define (decode bits tree)
  (define (decode-1 bits current-branch)
    (if (null? bits)
        '()
        (let ((next-branch (choose-branch (car bits) current-branch)))
          (if (leaf? next-branch)
              (cons (symbol-leaf next-branch)
                    (decode-1 (cdr bits) tree))
              (decode-1 (cdr bits) next-branch)))))
  (decode-1 bits tree))
(define (choose-branch bit branch)
  (cond ((= bit 0) (left-branch branch))
        ((= bit 1) (right-branch branch))
        (else (error "bad bit: CHOOSE-BRANCH" bit))))

;;; Procedures for make the encoded tree ;;;
(define (adjoin-set x set)
  (cond ((null? set) (list x))
        ((< (weight x) (weight (car set))) (cons x set))
        (else (cons (car set)
                    (adjoin-set x (cdr set))))))
(define (make-leaf-set pairs)
  (if (null? pairs)
      '()
      (let ((pair (car pairs)))
        (adjoin-set (make-leaf (car pair)    ;; symbol
                               (cadr pair))  ;; frequency
                    (make-leaf-set (cdr pairs))))))
#+END_SRC

*** 練習問題 2.67 decode手続きによるメッセージの復号化

符号化木とサンプルメッセージの定義
#+BEGIN_SRC scheme
;; 符号化木
(define sample-tree
  (make-code-tree (make-leaf 'A 4)
                  (make-code-tree (make-leaf 'B 2)
                                  (make-code-tree (make-leaf 'D 1)
                                                  (make-leaf 'C 1)))))
;;((leaf A 4) ((leaf B 2) ((leaf D 1) (leaf C 1) (D C) 2) (B D C) 4) (A B D C) 8)
;; ||
;; \/
;;((leaf A 4)          ;; left-branch      (as a leaf)
;; (                   ;; right-branch 1 start
;;  (leaf B 2)         ;;   left-branch    (as a leaf)
;;  (                  ;;   right-branch 2 start
;;   (leaf D 1)        ;;     left-branch  (as a leaf)
;;   (leaf C 1)        ;;     right-branch (as a leaf)
;;   (D C)             ;;     symbols
;;   2                 ;;     weight
;;  )                  ;;   right-branch 2 end
;;  (B D C)            ;;   symbols
;;  4                  ;;   weight
;; )                   ;; right-branch 1 end
;; (A B D C)           ;; symbols
;; 8                   ;; weight
;;)

;; サンプルメッセージ
(define sample-message '(0 1 1 0 0 1 0 1 0 1 1 1 0))
#+END_SRC

decode手続きによる復号化
#+BEGIN_SRC scheme
(decode sample-message sample-tree)
> (A D A B B C A)
#+END_SRC

*** 練習問題 2.68 encode-symbolの設計

#+BEGIN_SRC scheme
#+END_SRC

*encode-symbol* の仕様
- 与えられた木に従って与えられた記号を符号化したビット列を返す
- 記号が木に含まれていなければエラーを出す

実装戦略
- 当該ノードが葉の場合
  - 探索している記号を持っているかをチェック（要らないかも）
  - 葉に辿り着くまでのビット列を返す
- 当該ノードが葉ではない（一般の木）場合
  - left-branchの記号集合とright-branchの記号集合に探索記号が入っているかチェック
    - left-branchに含まれている場合はビット列に0をappendして再帰呼び出し
    - right-branchに含まれている場合はビット列に1をappendして再帰呼び出し

回答
#+BEGIN_SRC scheme
;; 補助関数 from 2.3.3
(define  (element-of-set? x set)
  (cond ((null? set) #f)
        ((equal? x (car set)) #t)
        (else (element-of-set? x (cdr set)))))

;; Given procedure
(define (encode message tree)
  (if (null? message)
      '()
      (append (encode-symbol (car message) tree)
              (encode (cdr message) tree))))

;; My answer
(define (encode-symbol symbol tree)
  (if (leaf? tree)
      '()
      (cond ((element-of-set? symbol (symbols (left-branch tree)))
               (cons 0 (encode-symbol symbol (left-branch tree))))
            ((element-of-set? symbol (symbols (right-branch tree)))
               (cons 1 (encode-symbol symbol (right-branch tree))))
            (else (error "Unknown symbol:" symbol)))))
#+END_SRC

動作確認
#+BEGIN_SRC scheme
(define decoded-message (decode sample-message sample-tree))
decoded-message ;; (A D A B B C A)

(encode decoded-message sample-tree) ;; (0 1 1 0 0 1 0 1 0 1 1 1 0)
sample-message                       ;; (0 1 1 0 0 1 0 1 0 1 1 1 0)
#+END_SRC

*** 練習問題 2.69 successive-mergeの実装 (ハフマン木の生成)

色々練習
#+BEGIN_SRC scheme
(make-leaf-set '((A 4) (B 2) (C 1) (D 1))) ;;((leaf D 1) (leaf C 1) (leaf B 2) (leaf A 4))
#+END_SRC

*successive-merge* の仕様
- 集合の中で重みが最小の要素を =make-code-tree= を使って順番にくっつけていく
- 最後に要素が一つだけ残るようにする。その残った要素が求めるハフマン木となる

実装戦略
- 引数は葉のリストだが、これは一般の木のノードとしても扱える
- make-code-treeで最初と二番目（最も重みが小さい二つの）要素を結合し、
  木のノードを作成し、そのノードを三番目以降の要素からなるリストに
  adjoin-setで追加する
- 追加したリストに対してsuccessive-mergeを再帰的に呼び出す
- この構成だとsuccessive-mergeを呼び出す毎に最小の二つの要素が結合され
  木のノードとしてリストに追加され、引数のリストの要素数が一つずつ減っ
  ていくことになる。最後の要素のときにはそれまでの木のノードと最も重み
  の大きい葉ノードでmake-code-treeが実行されて最終的なハフマン木が生成
  される。
- 最後にこのハフマン木をadjoin-setした結果がsuccessive-mergeに渡される
  と、(cdr pairs) は'()になり、(car pairs)、つまりハフマン木そのもの
  を返すという処理になる

回答
#+BEGIN_SRC scheme
(define (generate-huffman-tree pairs)
  (successive-merge (make-leaf-set pairs)))

(define (successive-merge pairs)
  (cond ((null? pairs) '())
        ((null? (cdr pairs)) (car pairs))
        (else (let ((first (car pairs))
                    (second (cadr pairs)))
                (successive-merge (adjoin-set (make-code-tree first second)
                                              (cddr pairs)))))))
#+END_SRC

動作確認
#+BEGIN_SRC scheme
(define sample-pairs '((A 4) (B 2) (C 1) (D 1)))
(generate-huffman-tree sample-pairs)
> ((leaf A 4) ((leaf B 2) ((leaf D 1) (leaf C 1) (D C) 2) (B D C) 4) (A B D C) 8)

(generate-huffman-tree '()) ;; expected to ()
> ()
(generate-huffman-tree '((A 4))) ;; expected to (leaf A 4)
> (leaf A 4)
#+END_SRC

*** 練習問題 2.70

*** 練習問題 2.71

*** 練習問題 2.72
